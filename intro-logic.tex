\chapter{Introduction to Logic}
    \label{sec:introduction-logic}

    \emph{Logics} is a framework for studying \emph{``rules of argument''}~\cite{Hodges01ClassicalLogic} and can be used as a means for the specification of properties of hybrid programs.

    We give a concise overview about the concepts of logics on which the later chapters are based and which are essential for their understanding.


    \section{Propositional Logic}
        \label{sec:propositional-logic}

        % Classical logics knows two different \emph{truth values}: \emph{true} and \emph{false}.
        % classical logic \cite{reis2014cutelimination}
        % set of truth values true,false
        % every sentence always true or false
        % its sequent calculus is LK
        % valuation/model of a formula is an assignment of a truth value to each atomic proposition inside that formula

        The most familiar concept of logics is \emph{propositional logic} (eg.~\cite{Huth04LogicInCS}). It deals with \emph{declarative sentences}, so-called \emph{propositions}, which can be declared as either \emph{true} %($\ltrue$)
        or \emph{false}, %($\lfalse$)
        their truth value.
        Declarative sentences can be a composition of atomic (indecomposable) sentences, using the logical connectives: negation ($\lnot$), conjunction ($\land$), disjunction ($\lor$), implication ($\limply$) or equivalence ($\lbisubjunct$).

        Each connection admits a new truth value depending on the the truth values of its sub-sentences. They are defined by truth tables (see Figure~\ref{fig:logical-connectives}), specifying the result for each combination of input values. These operators can be partly expressed by each other, demanding, for example, only the definition of $\lnot$, $\land$, $\lor$.

        % TODO: truth tables
        \begin{figure}[b]
            \centering
            \begin{tabular}{c|cc}
                $\lnot$ & $\lfalse$ & $\ltrue$ \\ \hline
                 & $\ltrue$ & $\lfalse$
            \end{tabular}
            \vspace{1em}
            \hspace{2em}
            \begin{tabular}{c|cc}
                $\land$ & $\lfalse$ & $\ltrue$ \\ \hline
                $\lfalse$ & $\lfalse$ & $\lfalse$ \\
                $\ltrue$ & $\lfalse$ & $\ltrue$
            \end{tabular}
            \hspace{2em}
            \begin{tabular}{c|cc}
                $\lor$ & $\lfalse$ & $\ltrue$ \\ \hline
                $\lfalse$ & $\lfalse$ & $\ltrue$ \\
                $\ltrue$ & $\ltrue$ & $\ltrue$
            \end{tabular}
            \hspace{2em}
            \begin{tabular}{c|cc}
                $\limply$ & $\lfalse$ & $\ltrue$ \\ \hline
                $\lfalse$ & $\ltrue$ & $\ltrue$ \\
                $\ltrue$ & $\lfalse$ & $\ltrue$
            \end{tabular}
            \hspace{2em}
            \begin{tabular}{c|cc}
                $\lbisubjunct$ & $\lfalse$ & $\ltrue$ \\ \hline
                $\lfalse$ & $\ltrue$ & $\lfalse$ \\
                $\ltrue$ & $\lfalse$ & $\ltrue$
            \end{tabular}
            \caption{Definition of logical connectives.}
            \label{fig:logical-connectives}
        \end{figure}

        % logical symbols (and, or, imply, not, forall, exists, equality???) ()
        % parentheses


        % it is predicate logic, not propositional
        % propositional: no =, no quantifiers, no functions/predicates, only true/false constant symbols (= predicates of arity 0 = propositions)

        % TODO: truth values
        % model for a formula: assignment of truth values to each atomic formula
        % such model is called valuation

                    % variable symbol = logical variable



    \section{First-Order Logic}
        \label{sec:first-order-logic}

        \emph{First-order logic} (\FOL) extends propositional logic with quantifiers, variables, functions and predicates.
        We introduce first-order logic similar to the definitions given in \cite{Platzer10HybridSystems} and \cite{Huth04LogicInCS}. More subtleties are adapted from \cite{Hodges01ClassicalLogic}, \cite{Buss98HandbookProofTheory} and \cite{Rautenberg10ConciseLogic}.

        % though with a different notation/nomenclature
        % predicate logic
        % Precisely define a set of symbols and their roles
        \FOL is a class of logics, whose incarnations differ in their set of symbols and their roles, but follow all the same basic structure.
        Besides the logical connectives from propositional logic, first-order logic comprises extralogical symbols (functions and predicates) as well as logical variables, which altogether form its alphabet.

        \emph{Logical variables} provide a means of abstraction and refer to objects about which one wants to reason. They are usually called $x,y,z$. 

        \emph{Functions} take values as argument and give back a new value, which can be of any type. Function symbols stand for a function and are denoted by $f,g,h$.

        In contrast to functions, \emph{predicates} return a truth value (\emph{true} or \emph{false}), depending on the values of their arguments.
        Predicate symbols are usually written as $p,q,r$.

        The \emph{arity} of a function or predicate symbol is the number of arguments it expects.
        Functions can be of arity zero, i.e.\ without any argument.
        For clarity, we will treat these so-called \emph{constants} (or nullary functions) separately and write their symbols as $a,b,c$.

        % The arities are specified by the signature $\signature$.

        \subsection{Syntax}
            \label{sec:FOL-syntax}

            First-order logic inductively defines a syntax of well-formed \emph{logical formulas} over an alphabet containing different kinds of symbols.

            The syntax only defines rules which specify how the given symbols can be textually combined. At this stage, they have no specific meaning yet.

            The alphabet $\signature\cup\varsymbols$ comprises the \emph{signature} $\signature$ of the theory, which is a set of predicate, function and constant symbols, and the set of logical variable symbols $\varsymbols$.

            Terms are the expressions which denote feasible arguments for functions and predicates.
            \begin{definition}[Terms]
                For a given \emph{signature} $\signature$ and set of variable symbols $\varsymbols$, the well-formed terms are either logical variables, constants or functions applied to terms:
                The set of all \emph{terms} $\terms$ is the smallest set with
                \begin{enumerate}
                    \item If $x\in\varsymbols$ then $x\in\terms$.
                    \item If $c\in\signature$ is a constant symbol, then $c\in\terms$.
                    \item If $f\in\signature$ is a function symbol of arity $n\geq 1$ and $\istrm{i}\in\terms$ for $i=\range{1}{n}$, then $f(\range{\istrm{1}}{\istrm{n}})\in\terms$.
                \end{enumerate}
                This definition can alternatively be written as grammar in Backus-Naur form
                \begin{equation*}
                    \astrm,\istrm{i} \Coloneqq
                        x \mid
                        c \mid
                        f(\range{\istrm{1}}{\istrm{n}})
                \end{equation*}
                where $x$ is ranging over the set of logical variables $\varsymbols$, $c$ over the nullary functions in $\signature$ and $f$ over the elements in $\signature$ with arity $n\geq 1$.
            \end{definition}

            Formulas are expressions which admit a truth value.
            \begin{definition}[First-Order Formulas]
                For given $\signature$ and $\varsymbols$, the well-formed \emph{formulas} of a first-order logic are words formed by recursive combination of signature-symbols with logical operator symbols:
                The set of formulas $\FOLformulas$ is the smallest set with
                % TODO: term1=term2, or is this predicate?
                \begin{enumerate}
                    \item If $p\in\signature$ is a predicate symbol of arity $n\geq 0$ and $\istrm{i}\in\terms$ for $i=\range{1}{n}$, then $p(\range{\istrm{1}}{\istrm{n}})\in\FOLformulas$.
                    \item If $\asfml,\bsfml\in\FOLformulas$, then $\lnot\asfml,(\asfml\land\bsfml),(\asfml\lor\bsfml),(\asfml\limply\bsfml)\in\FOLformulas$.
                    \item If $\asfml\in\FOLformulas$ and $x\in\varsymbols$ then $(\lforall{x}{\asfml})\in\FOLformulas$ and  $(\lexists{x}{\asfml})\in\FOLformulas$.
                \end{enumerate}
                We may again write this as
                \begin{equation}
                    \asfml,\bsfml \Coloneqq
                        p(\range{\istrm{1}}{\istrm{n}}) \mid
                        \lnot\asfml \mid
                        \asfml\land\bsfml \mid
                        \asfml\lor\bsfml \mid
                        \asfml\limply\bsfml \mid
                        \lforall{x}{\asfml} \mid
                        \lexists{x}{\asfml}
                \end{equation}
                where $p\in\signature$ ranges over the predicate symbols (of arity $k\geq 1$), $\istrm{i}\in\terms$ over the terms and $x\in\varsymbols$ over the variable symbols.
            \end{definition}

        \subsection{Semantics}
            \label{sec:FOL-semantics}
            
            The \emph{semantics} of a first-order logic specifies the meaning of each symbol occurring in terms and formulas with the goal to assign a \emph{truth value} to a full formula.
            Moreover, this requires the \emph{assignment} of a concrete value to each variable symbol, chosen from a \emph{universe}, the domain of discourse containing all objects of consideration.

            \begin{definition}[Universe]
                A non-empty set $\universe$ containing the concrete objects of discourse, is called \emph{universe}.
            \end{definition}

            \begin{definition}[Interpretation]
                An \emph{interpretation} $\interpret$ assigns concrete elements to their corresponding symbols in a given signature $\signature$. It consists of:
                \begin{enumerate}
                    \item for each constant symbol $c\in\signature$ a value $\interpret[c]\in\universe$,
                    % TODO: reference to cartesian product
                    \item for each function symbol $f\in\signature$ of arity $k\geq 1$ a function $\interpret[f]\from\universe^k\to\universe$ with $k$ arguments,
                    \item for each predicate symbol $p$ of arity $k\geq 1$ a relation $\interpret[p]\subseteq\universe^k$.
                \end{enumerate}
            \end{definition}

            % Interpretation associates $f$ with $\interpret{f}(\range{d_1}{d_n})\in\universe$ value of function at position $(\range{d_1}{d_n})\in\universe^k $

            A predicate $p$ is \emph{true} at position $(\range{d_1}{d_n})\in\universe^k$ if and only if $(\range{d_1}{d_n})\in\interpret[p]$.
            An alternative but equivalent formulation uses the characteristic function of the relation $\interpret[p]\from\universe^n\to\{\ltrue,\lfalse\}$, where $p$ is true at $(\range{d_1}{d_n})\in\universe^n$ if and only if $\interpret[p](\range{d_1}{d_n})=\ltrue$.

            % provide seperate characterisation, meaning of the connectives
            % truth tables
            % to define what is true and false
            % semantics is equivalent to proof theory


            % relationship
            % $\range{\asfml_1}{\asfml_n}\models\bsfml$
            % looking at truth values of atomic formulas in premises and conclusion, how manipulated by logical connectives, defined by a table for all possible cases
            % calculate truth value of formula from truth value of atomic propositions

            As mentioned above, logical variables are only place holders and need, at some stage, refer to a concrete value. Their interpretation is realized by an assignment.

            \begin{definition}[Assignment]
                An \emph{assignment} is a map $\assignment\from\varsymbols\to\universe$ which assigns a value of the universe to each variable symbol $x\in\varsymbols$.
            \end{definition}

            \begin{definition}[Model]
                A \emph{model} is the triple $\model=(\universe,\interpret,\assignment)$ of a universe $\universe$, an interpretation $\interpret$ and an assignment $\assignment$.
            \end{definition}

            We write $\modif{\model}{x}{a}$ for the model which differs from the model $\model$ only in the assignment to the logical variable $x$, to which the value $a\in\universe$ is allocated.

            Given the information of a model, we can finally evaluate a formula, i.e.\ decide on its truth value.

            The valuation of terms and formulas is again defined inductively.
            \begin{definition}[Valuation of Terms]
                For $\terms$ a \emph{valuation} $\ivaluation{\IFOL}{\phi}$ is defined by
                \begin{enumerate}
                    \item $\ivaluation{\IFOL}{x} = \assignment(x)$ for each logical variable $x\in\varsymbols$
                    \item $\ivaluation{\IFOL}{c} = \interpret[c]$ for each constant $c\in\signature$
                    \item $\ivaluation{\IFOL}{f(\range{\istrm{1}}{\istrm{n}})} = \interpret[f](\range{\ivaluation{\IFOL}{\istrm{1}}}{\ivaluation{\IFOL}{\istrm{n}}})$ for each function symbol $f\in\signature$ of arity $n\geq 1$.
                \end{enumerate}
            \end{definition}

            The meaning of the logical connective symbols, how they preserve a truth value, is defined in the truth tables, given in Figure~\ref{fig:logical-connectives}.
            % TODO: translation into natural language?
            \begin{definition}[Valuation of First-Order Formulas]
                The \emph{valuation} of the first-order formulas $\FOLformulas$ in the interpretation $\interpret$ under the assignment $\assignment$ is given by
                \begin{enumerate}
                    \item $\imodel{\IFOL}{p(\range{\istrm{1}}{\istrm{n}})} = \interpret[p](\range{\imodel{\IFOL}{\istrm{1}}}{\imodel{\IFOL}{\istrm{n}}})$ for predicates $p$
                    \item the conjunction $\imodel{\IFOL}{\astrm\land\bstrm} = \ltrue$ iff $\imodel{\IFOL}{\astrm}=\ltrue$ and $\imodel{\IFOL}{\bstrm}=\ltrue$.
                    \item the disjunction $\imodel{\IFOL}{\astrm\lor\bstrm} = \ltrue$ iff $\imodel{\IFOL}{\astrm}=\ltrue$ or $\imodel{\IFOL}{\bstrm}=\ltrue$.
                    \item the negation $\imodel{\IFOL}{\lnot\astrm} = \ltrue$ iff $\imodel{\IFOL}{\astrm} \neq \ltrue$.
                    \item the implication $\imodel{\IFOL}{\astrm\limply\bstrm} = \ltrue$ iff $\imodel{\IFOL}{\astrm} \neq \ltrue$ or $\imodel{\IFOL}{\bstrm}=\ltrue$.
                    \item the universal quantifier $\imodel{\IFOL}{\lforall{x}{\astrm}} = \ltrue$ iff $\imodel{\imodif[algebra]{\IFOL}{x}{a}}{\astrm} = \ltrue$ for all $a\in\R$.
                    \item the existential quantifier $\imodel{\IFOL}{\lexists{x}{\astrm}} = \ltrue$ iff $\imodel{\imodif[algebra]{\IFOL}{x}{a}}{\astrm} = \ltrue$ for some $a\in\R$.
                \end{enumerate}
                The statement $\imodel{\IFOL}{\astrm}=\ltrue$ can also be written as $\imodels{\IFOL}{\astrm}$, the so-called \emph{satisfaction relation}.
                One says that $(\interpret,\assignment)$ \emph{satisfies} $\asfml$, that $(\interpret,\assignment)$ is a model for $\asfml$ or that $\asfml$ is \emph{true} in $\interpret$ under $\assignment$.

                A formula $\asfml$ is called \emph{valid} (or a \emph{tautology}) if $\imodels{\IFOL}{\asfml}$ for every model $\model$ (i.e.\ for all possible interpretations $\interpret$ and assignments $\assignment$). In this case, one writes shortly $\models\asfml$.
            \end{definition}

            % formula is satisfieable, valid, or neither
            % satisfieable if there is at least one model in which formula evaluates to true
            % valid if always evaluates to true, in every model

        % TODO: free variables
        \subsection{Variable Binding and Substitution}
            \label{sec:FOL-variable-binding}

            Quantifiers in formulas bind occurrences of variables in such way that a \emph{bound variable} does not need an assignment in order to determine a truth value for the formula.
            In contrast, a \emph{free variable} requires an assignment.

            % sentence is formula without free variables, has a determined truth value

            \begin{definition}[Variable binding]
                A variable $x$ in a formula $\asfml$, which occurs in subformulas of the form $\lforall{x}{\bsfml}$ or $\lexists{x}{\bsfml}$, is \emph{bound} in $\asfml$.
                If it appears in $\asfml$ outside the scope ($\bsfml$) of a quantifier, it is called \emph{free}.
            \end{definition}

            Variables are place holders and hence demand a means for being replaced with concrete information. With a little restriction, it is possible to substitute free variables by another term.

            \begin{definition}[Admissible substitution]
                The term $\astrm$ is an \emph{admissible substitution} for $x$ in $\asfml(x)$, if no free occurrence of $x$ in $\asfml$ is in the scope of a $\forall{y}$ or $\lexists{y}$ for any variable $y$ appearing in $t$.

                In this case, we define the \emph{substitution} $\substl[\asfml]{x}{\astrm}$ of the variable $x$ by the admissible term $\astrm$ in the formula $\asfml$ as the formula obtain from $\asfml$ by replacing each occurrence of the free variable $x$ outside the scope of a quantifier by $\astrm$.
            \end{definition}

            This restriction is necessary for the soundness of the quantifier axioms given in the next section.

            We agree on the following notational convention
            (which is not to be confused with the syntax for functions and predicates with arguments):
            When me mention $\asfml(x)$ and $\asfml(\astrm)$ in the same context, we mean that $x$ is a free variable of the formula $\asfml$ and that $\asfml(\astrm)$ is $\substl[\asfml]{x}{\astrm}$.

        \subsection{Proof Theory}
            \label{sec:FOL-proof-theory}

            % FIXME: when to use vDash instead of models? because of \entails in semantics
            % test $\models\vDash $
            % establish validity by proofs
            
            Given an interpretation and assignment, the semantics of a logic allow to compute the truth value of a formula. This means, checking satisfaction is easy.
            However to check the validity of a formula by the semantics is difficult. We would need to check all possible interpretations and assignments.

            To tackle that problem, one introduces the concept of a proof calculus, which allows to show the validity of a formula.
            A \emph{formal proof} derives an obviously valid formula from the initial formula, using a set of \emph{sound} derivation rules.

            In general, it can be difficult to find a proof.
            But once a proof is found, it can easily be verified by the validity of the proof rules.
            This means, as opposed to the semantics, showing that a formula is not valid using the proof calculus, is difficult.
            Using the semantics, it is sufficient to find a counter-example. But how can one show that there is no proof?
            A counterexample is a witness for non-validity, a (formal) proof is a witness for validity. 

            % if not valid, there is a counterexample, an interpretation and assignment for which not true, ie false


            % proof for establishing evidence of assertions, like $\lsequent{\Gamma}{\astrm}$ valid
            % not useful for $\lsequent{\Gamma}{\astrm}$ not valid

            These two characterizations of truth, semantics and proof calculus, need to be equivalent.
            A proof calculus is \emph{sound} if invalid sequents are not derivable and \emph{complete} if every valid sequent can be derived.

            % valid formulas are of particular interest, hold under all circumstances, ie for all interpretations and assignments
            % need to identify these, check validity

            % proof rules are derived from axioms or easy valid formulas
            % proof of a sequent is a tree, initial sequent as root, axioms as leaves

            % $w\models\Gamma$ means $w\models\asfml$ for all $\asfml\in\Gamma$
            % definition
            % logical consequence $\Gamma\models\bsfml$ if $w\models\bsfml$ for every model of $\Gamma$
            % $w\models\Gamma\limply w\models\bsfml$ for all valuations w
            % super charged symbol but context

            % $T$ entails $\asfml$, all interpretations satisfying $T$ also satisfy $\asfml$
            % $\asfml$ is valid, if every interpretation makes it true

            % a sequent is deriveable/provable in proof calculus $C$, $T|-_C\asfml$ if there is a formal proof in the calculus for the sequent

            % judgement of form
            % \begin{equation}
            %     \lsequent{\range{\asfml_1}{\asfml_n}}{\bsfml}
            % \end{equation}
            % called sequent
            % sets may be empty
            % sequent is valid, if there is a proof

            There are different styles of formal logical argumentation. We consider so-called Hilbert deduction systems, in which a proof can be represented.

            \subsubsection{Hilbert Calculus}
                \label{sec:hilbert-calculus}

                \begin{figure}[t]
                    \centering
                    \begin{calculuscollections}{\textwidth}
                    \begin{calculus}
                        \cinferenceRule[L1|$\Lambda1$]{premise charge}{
                            \linferenceRule[impl]{
                                \asfml
                            }{
                                (\bsfml\limply\asfml)
                            }
                        }{}
                        \cinferenceRule[L2|$\Lambda2$]{Frege's formula}{
                            \linferenceRule[impl]{
                                \big(\asfml\limply(\bsfml\limply\csfml)\big)
                            }{
                                \big((\asfml\limply\bsfml)\limply(\asfml\limply\csfml)\big)
                            }
                        }{}
                        \cinferenceRule[L3|$\Lambda3$]{}{
                            \linferenceRule[impl]{
                                (\lnot\asfml\limply\lnot\bsfml)
                            }{
                                \big((\lnot\asfml\limply\bsfml)\limply\asfml\big)
                            }
                        }{}
                        \cinferenceRule[L4|$\Lambda4$]{}{
                            \linferenceRule[impl]{
                                \lforall{x}{\asfml(x)}
                            }{
                                \asfml(y)
                            }
                        }{$y$ admissible for substitution}
                        \cinferenceRule[L5|$\Lambda5$]{}{
                            \linferenceRule[impl]{
                                \lforall{x}{(\asfml\limply\bsfml)}
                            }{
                                (\asfml\limply\lforall{x}{\bsfml})
                                \qquad\qquad
                            }
                        }{$x$ is not free in $\asfml$}
                    \end{calculus}
                    \begin{calculus}
                        \cinferenceRule[MPfol|MP]{modus ponens rule}{
                            \linferenceRule[sequent]{
                                \asfml\limply\bsfml & \asfml
                            }{
                                \bsfml
                            }
                        }{}
                        \cinferenceRule[GenAfol|$\forall$]{forall generalization rule}{
                            \linferenceRule[sequent]{
                                \asfml
                            }{
                                \lforall{x}{\asfml}
                            }
                        }{}
                    \end{calculus}
                    \end{calculuscollections}
                    \caption{A complete axiomatization of \FOL and Hilbert-calculus deduction rules.}
                    \label{fig:fol-axioms}
                \end{figure}

                A Hilbert-style deduction system is based on a finite set of selected tautologies with the role of axioms and only a small number of inference rules.

                In such a calculus, a formal \emph{proof} is a derivation of the formula to be shown (conclusion) from the axioms and premises by applying in each step one of the deduction rules.
                In such a proof, every line is again an unconditional tautology.
                A formula $\asfml$ is called \emph{derivable} from the premises in the given calculus, if there exists a derivation with conclusion $\asfml$.

                The axiomatization consists of logical \emph{axiom schemes}. These describe the countably infinite number of axioms the deduction system comprises. A concrete axiom is obtained by replacing the placeholders by concrete formulas.

                There are many possible choices for an axiom system. However the selection should be sufficiently strong, such that each tautology is derivable by the given inference rules.
                % theory of $\model$ is set of sentences satisfied by $\model$
                % generally, theory is set of sentences
                % model class of theory $T$: all interpretations which satisfy $T$ (all sentences given in T)
                % if $K$ (interpretations) is model class of theory $T$, then $T$ is set of axioms for $K$ (\cite{Hodges01ClassicalLogic})

                A possible sound and complete axiomatization for first-order logic is given in \cite{Bimbo14ProofTheory} and shown in Figure~\ref{fig:fol-axioms}.                
                It combines axioms for classical propositional logic with axioms for quantifiers and relies only on two deduction rules: \emph{modus ponens}~(\irref{MPfol}), which infers formula $\bsfml$ from the hypotheses $\asfml$, and $\asfml\limply\bsfml$ and \emph{quantifier-generalization}~(\irref{GenAfol}).
                % TODO: how does GenA work?
                
                % \irref{L1} premise charge
                % \irref{L2} Frege's formula
                % useful when one wants to add further axioms to first-order base
                % judgement is any formula of given (first-order) logic
                % theorems: formulae appearing in concluding judgement of a valid proof $\lsequent{}{\bsfml}$


            % TODO: natural deduction calculus
            % \subsubsection{Natural Deduction}
            %     \label{sec:natural-deduction}

            %     The \emph{natural deduction} is a calculus of the so-called Gentzen style,
            %     which relies on only a few axioms but an exhaustive collection of inference rules operating on sequents.

            %     By applying these rules one infers formulas from formulas and finally deduces a conclusion from the given set of promises.

            %     \cite{Rautenberg10ConciseLogic}

            %     % TODO: replace \Gamma with \asfmls, \Delta with \bsfmls
            %     \begin{figure}[t]
            %         \begin{calculuscollections}{\textwidth}
            %         \begin{calculus}
            %             \cinferenceRule[FOLax|ax]{axiom, initial rule}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{}{}
            %                 }{
            %                     \lsequent{\asfmls,\asfml}{\asfml}
            %                 }
            %             }{}
            %             \cinferenceRule[FOLmono|$\land$i]{monotonicity rule}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls}{}
            %                 }{
            %                     \lsequent{\asfmls}{}
            %                 }
            %             }{}
            %             \cinferenceRule[FOLandi|$\land$i]{and introduction}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls}{\asfml}
            %                     &\lsequent{\asfmls}{\bsfml}
            %                 }{
            %                     \lsequent{\asfmls}{\asfml\land\bsfml}
            %                 }
            %             }{}
            %             \cinferenceRule[FOLande|$\land$i]{and elimination}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls}{\asfml\land\bsfml}
            %                 }{
            %                     \lsequent{}{}
            %                 }
            %             }{}
            %             \cinferenceRule[FOLnotr|$\land$r]{not elimination}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls}{\bsfml}
            %                     &\lsequent{\asfmls}{\lnot\bsfml}
            %                 }{
            %                     \lsequent{\asfmls}{\asfml}
            %                 }
            %             }{}
            %             \cinferenceRule[FOLnotl|$\land$l]{not elimination}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls,\asfml}{\bsfml}
            %                     &\lsequent{\asfmls,\lnot\asfml}{\bsfml}
            %                 }{
            %                     \lsequent{\asfmls}{\bsfml}
            %                 }
            %             }{}
            %             \cinferenceRule[FOLalle|$\forall$e]{forall elimination}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls}{\lforall{x}{\asfml}}
            %                 }{
            %                     \lsequent{\asfmls}{\subst[\asfml]{x}{t}}
            %                 }
            %             }{collision free}
            %             \cinferenceRule[FOLalli|$\forall$i]{forall introduction}{
            %                 \linferenceRule[sequent]{
            %                     \lsequent{\asfmls}{\subst[\asfml]{x}{y}}
            %                 }{
            %                     \lsequent{\asfmls}{\lforall{x}{\asfml}}
            %                 }
            %             }{y not in free vars von $\Gamma$ and vars von $\asfml$}
            %         \end{calculus}
            %         \end{calculuscollections}
            %         % \caption{Delay differential dynamic logic axioms and proof rules.}
            %         % \label{fig:axioms}
            %     \end{figure}

            %     % ??? oder mehrere premises (sequents) oben one unten
            %     Every line of a proof is a conditional tautology, with zero or more conditions on the left side of the sequent and exactly one asserted proposition on the right hand side.

            %     premises: set of formulas $\range{\asfml_1}{\asfml_n}$
            %     conclusion $\bsfml$ single formula

            %     umforme premises with rules into conclusion
            %     this intention, written as
            %     from premisses conclude conclusion $\bsfml$


            %     in contrast to relationship $\range{\asfml_1}{\asfml_n}\models\bsfml$, see semantics

            %     Finding a proof can be difficult, because it might not be obvious which proof rules need to be applied and in what order.

            %     theorems: formulae appearing in concluding judgement of a valid proof $\lsequent{}{\bsfml}$

            %     % TODO: add ref to soundness
            %     rules well chosen, see soundness

    %         \subsubsection{Sequent Calculus}
    %             \label{sec:sequent-calculus}

    %             \cite{Buss98HandbookProofTheory,Reis14CutElimination,Bimbo14ProofTheory}
    %             partly like \cite{Platzer10HybridSystems}

    %             first-order sequent calculus called LK, nach Gentzen
    %             extension of propositional system PK

    %             \paragraph{Propositional Rules}
    %             \begin{calculus}
    %                 % same in all sources + WP
    %                 \cinferenceRule[LKax|ax]{axiom, initial rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{}{}
    %                     }{
    %                         \lsequent{\asfml}{\asfml}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKnotl|$\lnot$l]{not left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml}
    %                     }{
    %                         \lsequent{\lnot\asfml,\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKnotr|$\lnot$r]{not right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfml,\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\lnot\asfml}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKimpr|$\limply$r]{imply right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfml,\asfmls}{\bsfmls,\bsfml}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml\limply\bsfml}
    %                     }
    %                 }{}
    %                 % as in Bimbo14ProofTheory, Platzer10HybridSystems, Buss98HandbookProofTheory
    %                 \cinferenceRule[LKorl|$\lor$l]{or left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfml,\asfmls}{\bsfmls}
    %                         &\lsequent{\bsfml,\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfml\lor\bsfml,\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKandr|$\land$r]{and right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml}
    %                         &\lsequent{\asfmls}{\bsfmls,\bsfml}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml\land\bsfml}
    %                     }
    %                 }{}
    %                 % as in Buss98HandbookProofTheory, Platzer10HybridSystems
    %                 \cinferenceRule[LKandl|$\land$l]{and left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfml,\bsfml,\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfml\land\bsfml,\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKorr|$\lor$r]{or right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml,\bsfml}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml\lor\bsfml}
    %                     }
    %                 }{}
    %                 % TODO: imply left rule
    %                 \cinferenceRule[LKimpl|$\limply$l]{imply left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{}{}
    %                     }{
    %                         \lsequent{\asfml\limply\bsfml,\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %             \end{calculus}

    %             \paragraph{Quantifier Rules}
    %             \begin{calculus}
    %                 % as in Buss98HandbookProofTheory, Reis2014CutElimination, WP
    %                 % and similiar to Bimbo14ProofTheory
    %                 \cinferenceRule[LKalll|$\forall$l]{forall left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\subst[\asfml]{x}{\astrm},\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\lforall{x}{\asfml},\asfmls}{\bsfmls}
    %                     }
    %                 }{arbitrary term $\astrm$?}
    %                 \cinferenceRule[LKallr|$\forall$r]{forall right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\subst[\asfml]{x}{y}}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\lforall{x}{\asfml}}
    %                     }
    %                 }{$y$ is not a free variable??? in $\asfmls,\bsfmls$}
    %                 \cinferenceRule[LKexl|$\exists$l]{exists left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\subst[\asfml]{x}{y},\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\lexists{x}{\asfml},\asfmls}{\bsfmls}
    %                     }
    %                 }{$y$}
    %                 \cinferenceRule[LKexr|$\exists$r]{exists right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\subst[\asfml]{x}{\astrm}}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\lexists{x}{\asfml}}
    %                     }
    %                 }{arbitrary term $\astrm$? which does not containvariables bound in $\asfml$}
    %             \end{calculus}

    %             \paragraph{Structural Rules}
    %             \begin{calculus}
    %                 % same in all sources + WP
    %                 \cinferenceRule[LKweakl|Wl]{weakening left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfml,\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKweakr|Wr]{weakening right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml}
    %                     }
    %                 }{}
    %                 % as in Buss98HandbookProofTheory, Bimbo14ProofTheory, Reis2014CutElimination, WP
    %                 \cinferenceRule[LKcontl|Cl]{contraction left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfml,\asfml,\asfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfml,\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKcontr|Cr]{contraction right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml,\asfml}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml}
    %                     }
    %                 }{}
    %                 % as in Buss98HandbookProofTheory, Bimbo14ProofTheory, WP
    %                 \cinferenceRule[LKperml|Cl]{permutation left rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls,\asfml,\bsfml,\csfmls}{\bsfmls}
    %                     }{
    %                         \lsequent{\asfmls,\bsfml,\asfml,\csfmls}{\bsfmls}
    %                     }
    %                 }{}
    %                 \cinferenceRule[LKpermr|Cr]{permutation right rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{\bsfmls,\asfml,\bsfml,\csfmls}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls,\bsfml,\asfml,\csfmls}
    %                     }
    %                 }{}
    %             \end{calculus}

    %             \paragraph{The Cut Rule}
    %             \begin{calculus}
    %                 % TODO: Cut-Rule
    %                 \cinferenceRule[LKcut|cut]{cut rule}{
    %                     \linferenceRule[sequent]{
    %                         \lsequent{\asfmls}{}
    %                         &\lsequent{\asfmls}{}
    %                     }{
    %                         \lsequent{\asfmls}{\bsfmls}
    %                     }
    %                 }{}
    %             \end{calculus}


    %             Gentzen style
    %             zero or more asserted propositions

    %             can be regarded as Hilbert-style calculus for deriving finite sequences instead of formulas \cite{Hodges01ClassicalLogic}

    %             sequent is a standard form for logical formulas
    %             antecedent $\Gamma$ assumed to be true
    %             succedent $\Delta$ one of these to be shown
    %             both finite sets of formulas
    %             $\lsequent{\Gamma}{\Delta}$, which means
    %             \begin{equation}
    %                 \landfold_{\asfml\in\Gamma}\asfml \limply \lorfold_{\bsfml\in\Delta}\bsfml
    %             \end{equation}

    %             comma in antecedent like conjunction, in succedent like disjunction
    %             rules decompose propositional structure of a formula leading to simpler ones

    %             empty sequent, both side empty, defined to be false
    %         % or sequent calculus
    %         % Gentzen, Hilbert
    %         % TODO: Bruch schreibweise, not iff, only if


    %         


    %         \subsubsection{Proof Rules}
    %             \label{sec:FOL-proof-rules}


    %             two groups: logical (operate on formula and sub-formulas) and structural (such as contraction=copy, weakening=erase, cut)

    %             %prop logic rules + rules for = and quantifiers

    %             sequent below horizontal line: conclusion
    %             sequents above horizontal line: premises

    %             \paragraph{Universal Quantification Rules}
    %                 % TODO: forall e <-> forall i
    %                 eliminates $\forall$
    %                 $\lforall{x}{\asfml}$ is true if we can replace quantified variable by any term (side condition, $\astrm$ needs be free for x in $\asfml$) and this remains true



    %                 soundness self-evident, since true for all, also for more concrete instance

    %                 \begin{example}
    %                     necessity for free

    %                 \end{example}

    %             \paragraph{Existential Quantification Rules}
    %                 % TODO: exists e <-> exists i
    %                 exists introduction

    %                 \begin{calculus}
    %                     \cinferenceRule[FOLexists|$\exists$]{exists generalization rule}{
    %                         \linferenceRule[sequent]{
    %                             \lexists{x}{\asfml}
    %                         }{
    %                             \subst[\asfml]{x}{\astrm}
    %                         }
    %                     }{}
    %                 \end{calculus}

    %                 $\astrm$ free for $x$ in $\asfml$
    %                 can deduce $\lexists{x}{\asfml}$ if we know that true for a concrete instance, witness

    %         \subsubsection{Ground Proving and Free Variable Proving}
    %             \label{sec:ground-proving-free-variable-proving}



        % \subsection{First-Order Logic of Real Arithmetic}
        %     \label{sec:FOL-R}

        %     Formulas of first-order logic of real-closed fields
        %     first-order logic of real arithmetic (\FOLR)
        %     formula of real arithmetic
        %     is first-order formula
        %     function/predicate symbols $ = {+,-,\cdot,/,=,<,\leq,>,\geq}$
        %     constant symbols $\Sigma$
        %     logical Variables $V$

        % \subsection{Decideability}
        %     \label{sec:decideability}

        %     (\cite{Hodges01ClassicalLogic})
        %     language (e.g. FOL) decideable if there is an algorithm which returns for any finite sequent if it is valid or not

        % TODO: mention correctness and completeness above in Proof calc 
        % \subsection{Correctness}
        %     \label{sec:correctness}

        %     $\bsfml$ deriveable from premises, then sequent is valid

        % \subsection{Completeness}
        %     \label{sec:completeness}

        %     given a valid sequent, then conclusion is deriveable from premises

        
    \section{Modal Logic}
        \label{sec:modal-logic}

        In propositional and first-order logic, each formula is either \emph{true} or \emph{false} for a given model.
        In this section, we present another concept of logics, called \emph{modal logic}, which allows different \emph{modes of truth}. An example is truth with respect to time.
        To that end, modal logic extends the language of propositional logic with two new unary connectives, $\lbox{}$ and $\ldiamond{}$, whose exact meaning depends on a specific incarnation of modal logics.
        We define modal logic as in \cite{Huth04LogicInCS,JaparidzeJongh98HandbookProofTheory}.

        % \subsection{Syntax}
        %     \label{sec:ML-syntax}

            % TODO: we write ... for propositions
            % TODO: grammar BNF -> words of finite length

            \begin{definition}[Syntax]
                The syntax of \emph{modal logic} is defined by the grammar
                \begin{equation*}
                    \asfml,\bsfml \Coloneqq
                        \lfalse \mid
                        \ltrue \mid
                        \asprop \mid
                        \lnot\asfml \mid
                        \asfml\land\bsfml \mid
                        \asfml\lor\bsfml \mid
                        \asfml\limply\bsfml \mid
                        \asfml\lbisubjunct\bsfml \mid
                        \lbox{\asfml} \mid
                        \ldiamond{\asfml}
                \end{equation*}
                with an atomic formula $\asprop$ from the set of propositions $P$. 
            \end{definition}

        % \subsection{Semantics}
        %     \label{sec:ML-semantics}

            \begin{definition}[(Kripke) Model]
                A \emph{model} $\model=(\worlds,\access,\valuation)$ of modal logic consists of
                \begin{enumerate}
                    \item a nonempty set of \emph{worlds/states} $\worlds$
                    \item an accessibility relation $\access\subseteq \worlds\times \worlds$ between the worlds
                    \item a labeling function $\valuation\from\worlds\to\powerset{P}$
                \end{enumerate}
                We write $\ireachability{\IML}{\aswrld,\bswrld}$ for $(\aswrld,\bswrld)\in\access$, meaning that the world $\bswrld$ is accessible from $\aswrld$.
            \end{definition}
            
            \begin{definition}[Semantics of modal formulas]
                The semantics of modal formulas is defined by a \emph{satisfaction relation}.
                It specifies inductively the truth value of each symbolic expression with regard to the worlds. A formula $\asfml$ is \emph{true} in a world $\aswrld$ or equivalently the world $\aswrld$ \emph{satisfies} formula $\asfml$, iff $\imodels{\IML}{\asfml}$.
                \begin{enumerate}
                    \item $\inonmodels{\IML}{\lfalse}$
                    \item $\imodels{\IML}{\ltrue}$
                    \item $\imodels{\IML}{\asprop}$ iff $\asprop\in \valuation(\aswrld)$
                    \item $\imodels{\IML}{\lnot\asfml}$ iff $\inonmodels{\IML}{\asfml}$
                    \item $\imodels{\IML}{\asfml\land\bsfml}$ iff $\imodels{\IML}{\asfml}$ and $\imodels{\IML}{\bsfml}$
                    \item $\imodels{\IML}{\asfml\lor\bsfml}$ iff $\imodels{\IML}{\asfml}$ or $\imodels{\IML}{\bsfml}$
                    \item $\imodels{\IML}{\asfml\limply\bsfml}$ iff $\imodels{\IML}{\bsfml}$ whenever $\imodels{\IML}{\asfml}$
                    \item $\imodels{\IML}{\asfml\lbisubjunct\bsfml}$ iff $\imodels{\IML}{\asfml}$ if and only if $\imodels{\IML}{\bsfml}$
                    % FIXME: \imodels{\iconcat[state=w]{\IML}}{\asfml}
                    \item $\imodels{\IML}{\lbox{\asfml}}$ iff $\bswrld\models\asfml$ for each $\bswrld\in\worlds$ with $\ireachability{\IML}{\aswrld,\bswrld}$
                    \item $\imodels{\IML}{\ldiamond{\asfml}}$ iff there is a $\bswrld\in\worlds$ with $\ireachability{\IML}{\aswrld,\bswrld}$ such that $\bswrld\models\asfml$
                \end{enumerate}
                A model $\model$ satisfies a formula if and only if each world of the model satisfies the formula. In this case, we write $\model\models\asfml$ and say $\asfml$ is \emph{valid} in $\model$.
                A formula $\asfml$ is \emph{valid}, if and only if it is true in every world of every model, written as $\models\asfml$.
            \end{definition}

        % \subsection{Axiomatizations}
        %     \label{sec:ML-Axiomatizations}

        %     % cite: Handbook of proof theory, chapter VII
        %     modal logic \textbf{K} axiomized by:
        %     1. all propositional tautologies in the given modal language
        %     2. $\lbox{\asfml\limply\bsfml}\limply (\lbox{\asfml}\limply\lbox{\bsfml})$
        %     with rules of modus ponens and necessitation

        %     modal logic \textbf{L}:
        %     adds $\lbox{(\lbox{\asfml}\limply\asfml)\limply\lbox{\asfml}}$

        %     K4: K + $\lbox{\asfml}\limply\lbox{\lbox{\asfml}}$

        %     K4 and L are closed under necessitation: called normal modal logics

        %     accessibility relation R
        %     R transitive -> K4
