\chapter{Delay Differential Dynamic Logic}
\label{ch:delay-differential-dynamic-logic}

% TODO: cite JAR2016 and JAR2008 and LMCS2012
We extend classical differential dynamic logic (\dL) (see e.g.~\cite{Platzer12LogicsDynSys}) with syntax, semantics, axiomatization and proof rules to support reasoning about hybrid dynamical systems with delay.

To that purpose, we allow delay differential equations in hybrid programs, which are then called \emph{delay hybrid program} (\dHP).

The definition of \emph{delay differential dynamic logic} (\ddL) provides all operators of first-order logic, as well as modal operators, in order to specify and verify reachability properties about the state of such \dHPs.

In the language of \ddL, we can not only model hybrid programs with DDEs in the continuous part, but also with temporal differences in the discrete fragment.
As an example consider a controller which approximates a derivative by a difference quotient.

% FIXME: only the syntax? or also semantics and axioms?
The logic \ddL is a superset of \dL, i.e.\ in the absence of any delay, \emph{delay differential dynamic logic} reduces to classical \emph{differential dynamic logic}.


% TODO: Abgrenzung zu Trace Semantics
    % The temporal character of delay differential equations (they depend on their own temporal evolution with limited horizon) suggests the introduction of trace semantics.
    %
    % However, we go the way of introducing transition semantics with an augmented state space.

\section{Syntax}
    \label{sec:syntax}

    Terms and formulas in \ddL, as well as \dHPs are defined as \emph{words} of finite length, produced by their corresponding grammars in Backus-Naur-form (BNF).
    % The syntax of is defined inductively by

    We define by $\allvars$ be the set of \emph{variables} and by $\diffvars\defeq\Set{\D{x} \with x\in\allvars}$ the corresponding set of \emph{differential symbols}.
    % TODO: call delay or delayed?
    Let $\constants\subset\nonposQ$ be the set of \emph{constant parameters}.
    All three sets are supposed to be finite.
    We denote $\delayvars\defeq\Set{\x[c] \with x\in\allvars,\ c\in\constants}$ as the set of \emph{delay variables} and $\delaydiffvars\defeq\Set{\Dx[c] \with \D{x}\in\diffvars,\ c\in\constants}$ as the set of \emph{delay differentials}.
    % TODO: finite sets, or sets infinite, but only finitely many symbols in one term/formula, Trm()
    % FIXME: parentheses

    % FIXME: just use \Q as set of constants, they have their semantics
    We will usually write variables as $x,y\in\allvars$ and their differential symbols as $\D{x},\D{y}\in\diffvars$.
    \emph{Function symbols} $f,g$, \emph{predicate symbols} $p,q$ and \emph{constant symbols} $a,b\in\Q$ are as in first-order logic (cf.\ Section~\ref{sec:first-order-logic}).

    Moreover, we write $\astrm(s),\bstrm(s)$ for \ddL terms, $\asfml(s),\bsfml(s)$ for \ddL formulas and $\asprg,\bsprg$ for \dHPs. For formulas of first-order logic of real arithmetic (\FOLR), we use the symbols $\asfmlfolR$ and $\bsfmlfolR$.

    \begin{definition}[s-Terms]\label{def:syntax-terms}
        The syntax of \emph{terms} of \emph{delay differential dynamic logic} is defined by the following grammar:
        \begin{align*}
            \astrm(s),\bstrm(s) \Coloneqq{}&
                \x[s] \mid
                \Dx[s] \mid
                \x[c] \mid
                \Dx[c] \mid
                a \mid\\
                & f(\range{\istrm{1}(s)}{\istrm{k}(s)}) \mid
                \astrm(s) + \bstrm(s) \mid
                \astrm(s) \cdot \bstrm(s) \mid
                \D{(\astrm(s))}
        \end{align*}
        % FIXME: is term' allowed? diff inv is only a FOLR formula? even for dL valid?
        % TODO: line breaks and explination text in syntax
        where $x\in\allvars,\D{x}\in\diffvars$ and $f$ is a function symbol of arity $k$.
        The symbol $a$ stands for a constant value from $\Q$. The constant parameters $c\in\constants$ are not allowed to be positive.
    \end{definition}

    The s-terms listed in the first line are called \emph{atomic}, as opposed to the \emph{composite} s-terms in the second line.
    % FIXME: what is f like?
    %extending \dL with symbols for \emph{delayed variables} and \emph{differentials}
    S-terms generally depend on the time parameter $s\in\nonposR$. This is why we write them as $\astrm(s)$.
    If a s-term $\astrm(s)$ does neither contain $\x[s]$ nor $\Dx[s]$, we say $s\notin\astrm(s)$ and abbreviate its notation to $\astrm$.
    Writing $\astrm(b)$ means that all occurrences of $s$ in $\astrm(s)$ have been replaced with $b\in\nonposQ$.
    % FIXME: or nonposR ? dilemma was kann ich explizit schreiben und was brauche ich nur implizit in der Theorie?
    Moreover, we abbreviate $\x[0]$ to $x$ and $\Dx[0]$ to $\D{x}$.
    Note that $s\notin\allvars\cup\diffvars\cup\constants$. It is a special variable symbol.

    The \emph{differential} $\D{(\astrm(s))}$ of a term $\astrm(s)$ is its syntactic (total) derivative, obtained by standard differentiation rules.
    Lemma~\ref{lm:derivatives} shows the validity of these rules and that the result is again a s-term.

    Subtraction can be defined using addition ($+$) and multiplication ($\cdot$), division would also be possible, if we can exclude any division by zero. The grammar allows in particular the construction of polynomial forms.

    \begin{example}
        Let us consider the s-term
        \begin{equation*}
            \astrm(s) \equiv 2\x[s] + \x[-\tau].
        \end{equation*}
        Setting $s=-1$ gives the term
        \begin{equation*}
            \astrm(-1) \equiv 2\x[-1] + \x[-\tau].
        \end{equation*}
    \end{example}

    Delay differential dynamic logic uses hybrid programs with delay differential equations as system model.
    The grammar defining these \emph{delayed hybrid programs} is the same as for classical \HPs (cf.~\cite{Platzer10HybridSystems,Platzer12LogicsDynSys,Platzer15Uniform}). The difference is only given by their semantics.
    % FIXME: which defines now DDEs instead of ODEs

    \begin{definition}[Delay Hybrid Programs]\label{def:syntax-HP}
        The syntax of \emph{delay hybrid programs} (\dHPs) is defined by
        % TODO: first-order logic of real arithmetic formulas include \x?
        \begin{equation*}
            \asprg,\bsprg \Coloneqq
                \hupdate{\humod{x}{\astrm}} \mid
                \Dupdate{\Dumod{\D{x}}{\astrm}} \mid
                % TODO: only FOLR?
                \htest{\asfml} \mid
                \hchoice{\asprg}{\bsprg} \mid
                % TODO: replace ; in HPs
                \asprg;\bsprg \mid
                \hrepeat{\asprg} \mid
                \hevolvein{\D{x}=\astrm}{\ivr}
        \end{equation*}
        where $\asprg,\bsprg$ denote \dHPs, $x$ a variable, $\astrm$ a term (possibly containing $x$ or $\x[c]$, but not $\x[s]$) and $\asfml$ a \ddL formula (not mentioning $\x[s]$ or $\Dx[s]$).
        The formula $\asfmlfolR$ is of \FOLR, containing only normal variable symbols from $\allvars$.
    \end{definition}

    % FIXME: double: this appears again after def
    Note that the syntax only allows autonomous DDEs, though with multiple constant delays.
    % time can be added as new variable t with \D{t}=1

    Atomic \dHPs are given by instantaneous discrete \emph{assignments}\footnote{Recall that $\hupdate{\humod{x}{\astrm}}$ means $\hupdate{\humod{\x[0]}{\astrm}}$} $\hupdate{\humod{x}{\astrm}}$ and \emph{differential assignments} $\Dupdate{\Dumod{\D{x}}{\astrm}}$, which change the value of the given variable only at the current time instant (not the past), \emph{tests} $\htest{\asfml}$, which pass only if the current state satisfies the formula $\asfml$ and aborts the program execution if not, as well as evolutions along \emph{delay differential equation} systems $\hevolvein{\D{x}=\astrm}{\ivr}$ of an arbitrary amount of time, but restricted by the evolution domain constraint $\ivr$.

    Compound \dHPs combine atomic programs, and comprise \emph{nondeterministic choices} $\hchoice{\asprg}{\bsprg}$, running either $\asprg$ or $\bsprg$, \emph{sequential compositions} $\asprg;\bsprg$, executing $\bsprg$ after $\asprg$ and \emph{nondeterministic repetitions} $\hrepeat{\asprg}$, repeating $\asprg$ any number of times, zero times included.

% Using this, in comparison to \dL extended syntax, we can write down both delay differential equations and ordinary differential equations in the form $\D{x}=\theta$, where $\theta=f(x,\x[-\tau])$ with a polynomial $f$.
    Observe that ODEs are still expressible by this syntax and that hybrid programs are hence only delayed hybrid programs with zero delay.

    % FIXME: where put general dL sources? only once at beginning


    \begin{definition}[s-Formulas]\label{def:syntax-formula}
        The syntax for \emph{formulas} of \emph{delay differential dynamic logic} is defined by the grammar
        \begin{align*}
            \asfml(s),\bsfml(s) \Coloneqq{}& % fixes missing space
                % TODO: better abbreviated notation for \holdssince, make forall only appear in semantics rhs
                \astrm(s) = \bstrm(s) \mid
                \astrm(s)\geq\bstrm(s) \mid
                p(\range{\istrm{1}(s)}{\istrm{k}(s)}) \mid
                \hs{\asfml(s)} \mid\\
                &\lnot\asfml(s) \mid
                \asfml(s)\land\bsfml(s) \mid
                \lforall{x}{\asfml(s)} \mid
                \lexists{x}{\asfml(s)} \mid
                \dbox{\asprg}{\asfml(s)} \mid
                \ddiamond{\asprg}{\asfml(s)}
        \end{align*}
        with $\astrm(s),\bstrm(s),\range{\istrm{1}(s)}{\istrm{k}(s)}$ as s-terms, $p$ as predicate symbol, $x$ as variable, and $\asprg$ as \dHP.
    \end{definition}

    These formulas combine connectives of propositional logic with first-order quantifiers (which all have standard meaning) and two modalities, describing \emph{necessary} and \emph{possible} properties.

    The other comparison operators $<,\leq,>$ and logic connectives $\lor,\limply,\lbisubjunct$ can be defined using $=,\geq,\land,\lnot$ and are hence not explicitly mentioned in the grammar.
    Analogously is $\lexists{x}{\asfml(s)}$ expressible as $\lnot\lforall{x}{\lnot\asfml(s)}$ and the modal formula $\dbox{\asprg}{\asfml(s)}$ ($\asfml(s)$ holds in the state after all runs of $\asprg$) by its dual $\ddiamond{\asprg}{\asfml(s)}\equiv\lnot\dbox{\asprg}{\lnot\asfml(s)}$ (there is at least one state reachable by $\asprg$ such that $\asfml(s)$ holds).
    The quantifiers $\forall$ and $\exists$ quantify over the elements of the state space $\statespace$.
    % FIXME: was state space mentioned before?

    Like the s-terms defined above, the s-formulas depend on a time parameter $s\in\closeddelayinterval$. The symbol $T$ is a symbolic constant related to the length of the domain of the state space, which is induced by the occurrence of delay symbols. Its value is defined by the static semantics.
    The only way to bind the variable $s$ in a formula $\asfml(s)$ is by using $\hs{\asfml(s)}$, which quantifies $s$ over the domain of the state space, except for the current time point $0$.
    % TODO: discuss why the latter is important

    We write $\asfml$ to indicate that $s$ is not a \emph{free variable} of $\asfml(s)$ and $\asfml(\past)$ with $\past\in\closeddelayinterval\subset\nonposR$ to express that each term $\astrm(s)$ in the formula was replaced by its corresponding $\astrm(r)$, even if the term appears in the scope of a $\hs{}$.
    % TODO: is r=0 here allowed, since hs does not include 0
    % TODO: or only which is not under the scope of a \hs? at the moment I overwrite each \hs
    Sometimes we want to emphasize that a formula depends on a variable $x$. Then we write $\asfml(x)$ and refer to $x$ as function and element of the state space, not only the value $\x[0]$ (cf.\ usage for $\forall$).
    A s-formula $\asfml(s)$, which contains ($\x[s]$ and) at least one $\x[c]$ for any $c\in\constants$ is called \emph{stiff}.
    % FIXME: c=0 allowed? denke nicht

    % TODO: on variables \allvars (signature)
    Formulas of first-order logic of real arithmetic constitute a subset of \ddL, i.e.\ every \FOLR formula is also a formula of delay differential dynamic logic (though not containing any delay).

    % TODO: find other notation for \hs, [] confuses with box modality
    \begin{convention}
        The frequently appearing fact that $\asfml(s)$ is not only supposed to hold for $s\in\delayinterval$ but also in $s=0$
        \begin{equation*}
            \hs{\asfml(s)}\land\asfml(0)
        \end{equation*}
        can also be written as
        \begin{equation*}
            \hsc{\asfml(s)}
        \end{equation*}
        For convenience, we allow the latter, abbreviated notation, which is implicitely replaced by the former, syntactically correct version.
    \end{convention}

    In order to simplify notation by eliminating parentheses, we agree on the following
    \begin{convention}
        The operators in \ddL formulas obey the following binding priorities (from highest to lowest):
        \begin{itemize}
            \item the quantifiers $\forall,\exists$ and the modal operators $\dbox{\cdot}{},\ddiamond{\cdot}{}$ bind strongest
            \item negation $\lnot$ binds stronger than
            \item conjunction $\land$ binds stronger than
            \item disjunction $\lor$ binds stronger than
            \item implication $\limply$ binds stronger than
            \item equivalence $\lbisubjunct$, which binds weakest.
        \end{itemize}
    \end{convention}

        % TODO: Move to static semantics
    Moreover, when a s-formula does not mention on the quantified parameter $s$, we can drop the quantifier $\hs{}$ in whose scope this formula appears.

    \begin{example}
        Consider the two well-formed \ddL formulas:
        \begin{align*}
            &\hs{(x+\x[s]\geq 0)}\\
            &\hs{(x+\x[-\tau]\geq 0)}
        \end{align*}
        The quantification over $s$ in the second formula is vacuous and can be dropped, what leads to the equivalent formula
        \begin{equation*}
            x+\x[-\tau]\geq 0.
        \end{equation*}
    \end{example}


\section{Dynamic Semantics}
    \label{sec:dynamic-semantics}

    % TODO: this is called valuation

    In this section, we give meaning to the syntax introduced above, by defining its semantics in a compositional way.

    Following the definitions and theoretical results on the solutions of  DDEs in Section~\ref{sec:definition-dde}, we define the \emph{state space} in \ddL as $\statespace$, the set of piecewise continuously differentiable functions on $\closeddelayinterval$ (cf.\ Definition~\ref{def:pw-cont-diff}).
    This means that a variable remembers a limited part of its past evolution, what demands hence a notion of underlying time.

    We denote by $\states$ the \emph{set of states}. A \emph{state} $\asstate\in\states$ is a mapping
    \begin{equation}
        \asstate \from \allvars\cup\diffvars \to \statespace
    \end{equation}
    which assigns a \emph{history} (function) to each variable and differential symbol.

    By $\modif{\asstate}{x}{y}$ we denote the state which is equal to state $\asstate$, except for the value of the variable $x$, which is set to $y\in\statespace$.

    % FIXME: modification of x in state and general specification of pw function associated to x
    %at the time $t=0$. The value of $x$ for the time before does not change.

    % FIXME: let interpretation $\interpret$ be fixed

    % FIXME: explain earlier why quantification over s needed

    \begin{definition}[Semantics of s-terms]\label{def:sematic-terms}
        The \emph{semantics} of a s-term $\astrm(s)$ in the state $\asstate\in\states$ with respect to the time instant $\past\in\closeddelayinterval$
        is a value in $\R$ and defined inductively as follows:
        \begin{enumerate}
            \item $\ivaluation{\IddL}{\x[s]} = \asstate(x)(\past)$ %for a variable $x\in\allvars$
            % FIXME: explain limit and case r=0
            \item $\ivaluation{\IddL}{\Dx[s]} = \asstate(\D{x})(\past) \defeq \lim_{t\downto \past} \frac{\asstate(x)(t)-\asstate(x)(\past)}{t-\past}$ (except in $\past=0$)
            % for a differential symbol $\D{x}\in\diffvars$
            \item $\ivaluation{\IddL}{\x[c]} = \asstate(x)(c)$ %for a variable $x\in\allvars$
            \item $\ivaluation{\IddL}{\Dx[c]} = \asstate(\D{x})(c) \defeq \lim_{t\downto c} \frac{\asstate(x)(t)-\asstate(x)(c)}{t-c}$ (except in $c=0$)
            \item $\ivaluation{\IddL}{a} = a$ %for a constant $a\in\constants$
            \item $\ivaluation{\IddL}{f(\range{\istrm{1}(s)}{\istrm{k}(s)})} = \interpret[f](\range{\ivaluation{\IddL}{\istrm{1}(s)}}{\ivaluation{\IddL}{\istrm{k}(s)}})$ %for a function symbol $f$
            \item $\ivaluation{\IddL}{\astrm(s)+\bstrm(s)} = \ivaluation{\IddL}{\astrm(s)} + \ivaluation{\IddL}{\bstrm(s)}$
            \item $\ivaluation{\IddL}{\astrm(s)\cdot\bstrm(s)} = \ivaluation{\IddL}{\astrm(s)} \cdot \ivaluation{\IddL}{\bstrm(s)}$
            % FIXME: derivation of terms with x'?
            \item $\ivaluation{\IddL}{\D{(\astrm(s))}} = \displaystyle\sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\astrm(s)}}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\astrm(s)}}{\partial \x[s]}$
        \end{enumerate}
        where $c\in\nonposQ$ is a non-positive rational number and $a\in\Q$. Rationals have their natural meaning.
    \end{definition}
        % FIXME: interpretation of $f$ is a smooth function?

    The meaning of the variable and differential symbols is determined by the state. Additionally, the value of a differential symbol has to coincide with the right derivative of the corresponding variable, except in $\past=0$, where they can mismatch.

    The meaning of the differential of an arbitrary term is the total derivative of its value with respect to the underlying continuous time.
    As a composition of smooth functions is $\ivaluation{\IddL}{\astrm(s)}$ smooth itself and hence these derivatives exist.
    The sum is finite, since each term only mentions finitely many variables.

    When a term $\astrm$ does not mention $s$, its valuation is independent of $\past\in\closeddelayinterval$. In this case we can write $\ivaluation{\iconcat[assign={}]{\IddL}}{\astrm}$, dropping the $\past$.

    If one explicitly specifies values for the derivatives, one needs to take care that they are compatible with their corresponding variables.
    % In the precondition, no values are associated to the differential symbols. In general, the initial function is only piecewise continuous.
    % Since for later time instances, the values of the differential symbols derive from the DDE, they become (locally) smooth function.

    \begin{definition}[Semantics of s-formulas]\label{def:semantic-formulae}
        The semantics of a \ddL formula $\asfml(s)$ is the subset of all states $\imodel{\IddL}{\asfml(s)}\subseteq\states$ in which $\asfml(s)$ is true at the time instant $\past\in\closeddelayinterval$. This set is given inductively by
        % TODO: mention interpretation I
        % FIXME: what is difference between \imodel and \ivaluation?
        % terms: ivaluation, formula: imodel, programms: ireachability
        % FIXME: display assign for formula semantics
        \begin{enumerate}
            % TODO: replace : in set by \with
            % FIXME: use notation forall ... : ...
            % FIXME: *version for lforall without parentheses
            % FIXME: forall quantifies over state space or over possible values (reals) for system parameters?
            \item $\imodel{\IddL}{\astrm(s)=\bstrm(s)} = \Set*{\asstate\in\states \with \ivaluation{\IddL}{\astrm(s)} = \ivaluation{\IddL}{\bstrm(s)}}$
            \item $\imodel{\IddL}{\astrm(s)\geq\bstrm(s)} = \Set*{\asstate\in\states \with \ivaluation{\IddL}{\astrm(s)}\geq\ivaluation{\IddL}{\bstrm(s)}}$
            \item $\imodel{\IddL}{p(\range{\istrm{1}(s)}{\istrm{k}(s)})} = \Set*{\asstate\in\states \with \left(\range{\ivaluation{\IddL}{\istrm{1}(s)}}{\ivaluation{\IddL}{\istrm{k}(s)}}\right)\in\interpret[p]}$
            \item $\imodel{\IddL}{\lnot\asfml(s)} = \scomplement{\left(\imodel{\IddL}{\asfml(s)}\right)} = \states\setminus\imodel{\IddL}{\asfml(s)}$
            \item $\imodel{\IddL}{\asfml(s)\land\bsfml(s)} = \imodel{\IddL}{\asfml(s)}\cap\imodel{\IddL}{\bsfml(s)}$
            \item $\imodel{\IddL}{\hs{\asfml(s)}} = \Set*{\asstate\in\states \with \mforall{\tilde{r}\in\delayinterval}\holds\asstate\in\imodel{\iconcat[assign=\tilde{r}]{\IddL}}{\asfml(s)}}$
            \item $\imodel{\IddL}{\lforall{x}{\asfml(s)}} = \Set*{\asstate\in\states \with \modif{\asstate}{x}{y}\in\imodel{\IddL}{\asfml(s)} \text{ for all } y\in\statespace}$
            \item $\imodel{\IddL}{\lexists{x}{\asfml(s)}} = \Set*{\asstate\in\states \with \modif{\asstate}{x}{y}\in\imodel{\IddL}{\asfml(s)} \text{ for some } y\in\statespace}$
            \item $\imodel{\IddL}{\dbox{\asprg}{\asfml(s)}} = \Set*{\asstate\in\states \with \bsstate\in\imodel{\IddL}{\asfml(s)} \text{ for all $\bsstate$ such that} (\asstate,\bsstate)\in\ireachability{\IddL}{\asprg}}$,\\ $=\Set*{\asstate\in\states \with \mforall{\bsstate\in\states}\holds(\asstate,\bsstate)\in\ireachability{\IddL}{\asprg} \mimply \bsstate\in\imodel{\IddL}{\asfml(s)}}$
            \item $\imodel{\IddL}{\ddiamond{\asprg}{\asfml(s)}} = \Set*{\asstate\in\states \with \bsstate\in\imodel{\IddL}{\asfml(s)} \text{ for some $\bsstate$ such that} (\asstate,\bsstate)\in\ireachability{\IddL}{\asprg}}$\\ $=\Set*{\asstate\in\states \with \mexists{\bsstate\in\states}\holds(\asstate,\bsstate)\in\ireachability{\IddL}{\asprg} \land \bsstate\in\imodel{\IddL}{\asfml(s)}}$
        \end{enumerate}
        The relation $\iget[access]{\IddL}$ is defined subsequently.
        The fact that formula $\asfml(s)$ is true in state $\asstate$ under the interpretation $\interpret$ at past time instant $\past\in\closeddelayinterval$, i.e.\ $\asstate\in\imodel{\IddL}{\asfml(s)}$ can also be written as $\interpret,\asstate,\past\models\asfml(s)$.
        A formula $\asfml(s)$ is called valid, written as $\models\asfml(s)$, if and only if $\asfml(s)$ is true in all states, for all $\past\in\closeddelayinterval$ and under all interpretations.
    \end{definition}

    As in classic first-order logic, the interpretation of a predicate symbol of arity n is a relation $\interpret[p]\subseteq\R^n$.

    % Atomic formulas (type 1 and 2) need to be combined with the quantification over s (6) in order to make sense. See Section \ref{sec:well-definedness}.

    % FIXME: text after HP semantics, add waht noted on white board
    % With the semantics of terms if follows for the meaning of $\dbox{\asprg}{\phi}$, that $\phi$ must only hold up to time $\tau$ before leaving the \HP $\asprg$. It is possible, that $\phi$ was not verified before, while \emph{executing} the \HP.

    % However when we apply the Rule of steps, we get the validity of $\phi$ for the entire trace.

    % TODO: is it better to only have xtau and not choice? What if both mentioned?
    % in formulae (such as safety condition or evolution constraint), we have two possibilities: only value at current time instant ($x$) or for entire last $\tau$ time $\x[-\tau]$

    % $\dbox{}{}$ and $\ddiamond{}{}$ only refer to last state and not intermediate states, as \dTL does.

    \begin{lemma}[Time Barcan formula]
        The box modality and the s-quantification  commute
        \begin{equation*}
            \imodel{\IddL}{\hs{\dbox{\asprg}{\asfml(s)}}} = \imodel{\IddL}{\dbox{\asprg}{(\hs{\asfml(s)})}}
        \end{equation*}
    \end{lemma}
    \begin{proof}
        Since $\mforall{x}\holds(p\mimply q(x))$ iff $p\mimply\mforall{x}\holds q(x)$, it holds
        \begin{multline*}
            \imodel{\IddL}{\hs{\dbox{\asprg}{\asfml(s)}}} =\\
            \begin{aligned}
                &= \Set*{\asstate\in\states \with \holdssince[\tilde{r}]{-T}\mforall{\bsstate\in\states}\holds \left((\asstate,\bsstate)\in\ireachability{\IddL}{\asprg} \mimply \bsstate\in\imodel{\iconcat[assign=\tilde{r}]{\IddL}}{\asfml(s)}\right)}\\
                &= \Set*{\asstate\in\states \with \mforall{\bsstate\in\states}\holds\holdssince[\tilde{r}]{-T}\left((\asstate,\bsstate)\in\ireachability{\IddL}{\asprg} \mimply \bsstate\in\imodel{\iconcat[assign=\tilde{r}]{\IddL}}{\asfml(s)}\right)}\\
                &= \Set*{\asstate\in\states \with \mforall{\bsstate\in\states}\holds\left((\asstate,\bsstate)\in\ireachability{\IddL}{\asprg} \mimply \holdssince[\tilde{r}]{-T}\bsstate\in\imodel{\iconcat[assign=\tilde{r}]{\IddL}}{\asfml(s)}\right)}\\
                &= \Set*{\asstate\in\states \with \mforall{\bsstate\in\states}\holds\left((\asstate,\bsstate)\in\ireachability{\IddL}{\asprg} \mimply \bsstate\in\imodel{\IddL}{\hs\asfml(s)}\right)}\\
                &= \imodel{\IddL}{\dbox{\asprg}{(\hs{\asfml(s)})}}
            \end{aligned}
        \end{multline*}
    \end{proof}

    \begin{example}
        The diamond modality does not commute with the s-quantification
        \begin{equation*}
            \imodel{\IddL}{\hs{\ddiamond{\asprg}{\asfml(s)}}} \neq \imodel{\IddL}{\ddiamond{\asprg}{\hs{\asfml(s)}}}
        \end{equation*}
        as shown by the following counter example for the state $\asstate(x)(\past)=0$, $\forall\past\in\closeddelayinterval$:
        \begin{align*}
            &\asstate\in\imodel{\iconcat[assign={}]{\IddL}}{\hs{\ddiamond{\hevolve{\D{x}=1}}{(\x[s]=1)}}}\\
            &\asstate\notin\imodel{\iconcat[assign={}]{\IddL}}{\ddiamond{\hevolve{\D{x}=1}}{\hs{(\x[s]=1)}}}
        \end{align*}

    \end{example}
    % TODO: do we accept that or restrict formula after modality to not having $s$ free? then, since s\notin\asprg commutes also for diamond


    % Since, with respect to \dL, the state space has been replaced, we need to redefine the semantics.

    \begin{definition}[Transition semantics of \dHPs]\label{def:semantic-dHP}
        The interpretation of a \dHP is given by a binary \emph{reachability relation} $\ireachability{\IddL}{\asprg}\subseteq\states\times\states$ between states:
        \begin{enumerate}
            % \item $\ireachability{\IddL}{a} = \interpret[a]$ for a program constant $a$
            % FIXME: astrm(s) without s, but need semantics klammer of terms without s/r
            \item\label{itm:sem-dHP-assgn} $\ireachability{\IddL}{\hupdate{\humod{x}{\astrm}}} =
                \Set*{(\asstate,\bsstate)\with \bsstate=\asstate \text{ except }
                \bsstate(x) = \left(\past\mapsto\begin{cases}
                    \ivaluation{\IddL}{\astrm(s)} & \past=0\\
                    \asstate(x)(\past) & \past\in\delayinterval
                \end{cases}\right)}$
            \item $\ireachability{\IddL}{\Dupdate{\Dumod{\D{x}}{\astrm}}} =
                \Set*{(\asstate,\bsstate)\with \bsstate = \asstate \text{ except }
                \bsstate(\D{x}) = \left(\past\mapsto\begin{cases}
                    \ivaluation{\IddL}{\astrm(s)} & \past=0\\
                    \asstate(\D{x})(\past) & \past\in\delayinterval
                \end{cases}\right)}$
            % FIXME: no \assign for FOLR formula \imodel
            \item $\ireachability{\IddL}{\htest{\asfml}} = \Set*{(\asstate,\asstate) \with \asstate\in\imodel{\iconcat[assign={}]{\IddL}}{\asfml}}$
            \item $\ireachability{\IddL}{\hchoice{\asprg}{\bsprg}} = \hchoice{\ireachability{\IddL}{\asprg}}{\ireachability{\IddL}{\bsprg}}$
            \item $\ireachability{\IddL}{\asprg;\bsprg} = \Set{(\asstate,\bsstate) \with (\asstate,\csstate)\in\ireachability{\IddL}{\asprg}, (\csstate,\bsstate)\in\ireachability{\IddL}{\bsprg}}$
            \item $\ireachability{\IddL}{\hrepeat{\asprg}}
                = \displaystyle\cupfold_{m\in\N_0}\ireachability{\IddL}{\asprg^m}$ with $\asprg^{m+1}\equiv (\asprg^m;\asprg)$ and $\asprg^0\equiv (\htest{\ltrue})$
            \item\label{itm:sem-HP-DDE} $\ireachability{\IddL}{\hevolvein{\D{x}=\astrm}{\ivr}} = \{(\asstate,\bsstate) \;\vert\; \mforall{\zeta\in[0,\duration]}\holds\trajectory(\zeta)\in\imodel{\IddL}{\hevolve{\D{x}=\astrm}\land\ivr}$ and $\asstate=\trajectory(0)$ on $\scomplement{\Set{\Dx[0]}}$ and $\bsstate=\trajectory(r)$ for a $\trajectory\from [0,\duration]\to\states\}$, i.e.\ there exists a $\duration\geq 0$ and a trajectory $\trajectory\from [0,\duration]\to\states$, which fulfills $\trajectory(\zeta)(\D{x})(r) \defeq \DD{\trajectory(t)(x)(\past)}{t}(\zeta) = \ivaluation{\iconcat[state=\trajectory(\zeta+\past),assign={}]{\IddL}}{\astrm}$ and satisfies $\ivr$ for all $r\in[-\min\Set{\zeta,T},0]$. For $\past\in [-T,-\min\Set{\zeta,T}\big)$ it holds $\trajectory(\zeta)(x)(\past)=\asstate(x)(\past+\zeta)$ for all variables $x$.
            % TODO: case r=0
        \end{enumerate}
    \end{definition}
    The semantics of a delay differential equation is motivated by the definition of a solution for a DDE-IVP (cf.\ Definition~\ref{def:solution-dde}), following the evolution for a nondeterministic period of time, as long as the evolution domain constraint holds.

    % To facilitate notation, we define a \emph{satisfaction relation} with respect to a DDE: the trajectory $\trajectory$ (which is a set of states) is said to \emph{satisfy} $\hevolvein{\D{x}=\astrm}{\ivr}$, written as $\trajectory\models\hevolvein{\D{x}=\astrm}{\ivr}$
    % TODO: :  fulfills DDE
    % $\trajectory$ solves the DDE and satisfies $\ivr$ in each time instant/state

    % The formula $\hevolve{\D{x}=\astrm(-\tau)}\land\ivr$ has dropped the $\hs{}$, all occurences of $x$ and $\D{x}$ of form with constant

    % TODO: if $R=0$:
    The initial value $\asstate(\D{x})(0)$ may not be compatible with the actual derivative of $x$. Following the evolution of a DDE, even for $\duration=0$, sets it properly, such that the rate of change of the values of a variable coincide with the values of the differential symbol.

    For the \emph{discrete assignment}, we only allow the values at the current time instant to be changed. A functional assignment would essentially allow to rewrite history, which is not permitted.

    The jump behavior caused by discrete assignments is the actual reason why we need to consider piecewise continuous evolutions, as defined in Def.~\ref{def:pw-cont-diff}.

    Time is implicit and usually not revealed. If it is explicitly needed, a clock variable $t$ can be introduced by $\hevolve{\D{t}=1}$.

    %TODO: super dense time: multiple assignments, only consider last assignment

    % in general, we do not write expression explicitely, just give possible intervals in precondition

    As a \FOLR formula, $\ivr$ do not contain any delayed variables and thus only depends on the values at the current time instant (and not on the entire interval $\delayinterval$).

    \begin{lemma}[Derivatives]\label{lm:derivatives}
        % FIXME: r=0 issue
        Standard analysis derivation rules also hold in the semantics of \ddL terms, i.e.\ the following equations are valid \ddL formulas
        \begin{align}
            \der{\x[s]} &= \Dx[s]\\
            %\Dx[s] &=\\
            \der{\x[c]} &= \Dx[c]\\
            %\Dx[b] &=\\
            \der{a} &= 0\\
            % \D{(f(\range{\istrm{1}}{\istrm{k}}))} &=\\
            \der{\astrm+\bstrm} &= \der{\astrm}+\der{\bstrm}\\
            \der{\astrm\cdot\bstrm} &= \der{\astrm}\cdot\bstrm + \astrm\cdot\der{\bstrm}\\
            % FIXME: is term' allowed? diff inv is only a FOLR formula? even for dL valid?
            %\D{(\astrm)}
        \end{align}
        This allows the usage of these rules on a syntactic level, what will be done in the form of axioms (see Section~\ref{sec:differential-axioms}).
    \end{lemma}
    \begin{proof}
        \begin{align*}
            % FIXME: semantics of x': must coincide with deriv of x
            % FIXME: semantics of Derivation: no I(s) and nu(s)
            \ivaluation{\IddL}{\D{(\x[s])}}
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\x[s]}}{\partial \x[c]}+ \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\x[s]}}{\partial \x[s]}\\
            &= \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\x[s]}}{\partial \x[s]}
            = \asstate(\D{x})(\past) = \ivaluation{\IddL}{\Dx[s]}
        \end{align*}
        \begin{align*}
            % delayed derivative
            \ivaluation{\IddL}{\D{(\x[c])}}
            &= \sum_{\x[d]\in\delayvars} \asstate(\D{x})(d)\frac{\partial\ivaluation{\IddL}{\x[c]}}{\partial \x[d]}+ \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\x[c]}}{\partial \x[s]}\\
            &= \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\x[c]}}{\partial \x[c]}
            = \asstate(\D{x})(c) = \ivaluation{\IddL}{\Dx[c]}
        \end{align*}
        \begin{align*}
            % constant
            \ivaluation{\IddL}{\D{(a)}}
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{a}}{\partial \x[c]}+ \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{a}}{\partial \x[s]}\\
            % &= \asstate(\D{x})(c)\frac{\partial\interpret[a]}{\partial \x[c]
            &= 0
        \end{align*}
        % \begin{align*}
        %     % chain rule
        %     % TODO: derivation of function symbol
        %     \ivaluation{\IddL}{\D{(f(\range{\istrm{1}(s)}{\istrm{k}(s)}))}} &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{f(\range{\istrm{1}(s)}{\istrm{k}(s)})}}{\partial \x[c]}\\ &+ \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{f(\range{\istrm{1}(s)}{\istrm{k}(s)})}}{\partial \x[s]}
        % \end{align*}
        \begin{align*}
            % addition rule
            % FIXME: line breaks in add rule
            \ivaluation{\IddL}{\D{(\astrm(s)+\bstrm(s))}}
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\astrm(s)+\bstrm(s)}}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\astrm(s)+\bstrm(s)}}{\partial \x[s]}\\
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\left(\ivaluation{\IddL}{\astrm(s)}+\ivaluation{\IddL}{\bstrm(s)}\right)}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\left(\ivaluation{\IddL}{\astrm(s)}+\ivaluation{\IddL}{\bstrm(s)}\right)}{\partial \x[s]}\\
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\astrm(s)}}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\astrm(s)}}{\partial \x[s]}\\
            &+ \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\bstrm(s)}}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\bstrm(s)}}{\partial \x[s]}\\
            &= \ivaluation{\IddL}{\D{(\astrm(s))}} + \ivaluation{\IddL}{\D{(\bstrm(s)}}
            = \ivaluation{\IddL}{\D{(\astrm(s))}+\D{(\bstrm(s))}}
        \end{align*}
        \begin{align*}
            % multiplication rule
            % FIXME: line breaks in mult rule
            \ivaluation{\IddL}{\D{(\astrm(s)\cdot\bstrm(s))}}
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\astrm(s)\cdot\bstrm(s)}}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\astrm(s)\cdot\bstrm(s)}}{\partial \x[s]}\\
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\left(\ivaluation{\IddL}{\astrm(s)}\cdot\ivaluation{\IddL}{\bstrm(s)}\right)}{\partial \x[c]} + \asstate(\D{x})(\past)\frac{\partial\left(\ivaluation{\IddL}{\astrm(s)}\cdot\ivaluation{\IddL}{\bstrm(s)}\right)}{\partial \x[s]}\\
            &= \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\astrm(s)}}{\partial \x[c]}\ivaluation{\IddL}{\bstrm(s)} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\astrm(s)}}{\partial \x[s]}\ivaluation{\IddL}{\bstrm(s)}\\
            &+ \sum_{\x[c]\in\delayvars} \asstate(\D{x})(c)\frac{\partial\ivaluation{\IddL}{\bstrm(s)}}{\partial \x[c]}\ivaluation{\IddL}{\astrm(s)} + \asstate(\D{x})(\past)\frac{\partial\ivaluation{\IddL}{\bstrm(s)}}{\partial \x[s]}\ivaluation{\IddL}{\astrm(s)}\\
            &= \ivaluation{\IddL}{\D{(\astrm(s))}}\cdot\ivaluation{\IddL}{\bstrm(s)} + \ivaluation{\IddL}{\astrm(s)}\cdot\ivaluation{\IddL}{\D{(\bstrm(s))}}\\
            &= \ivaluation{\IddL}{\D{(\astrm(s))}\cdot\bstrm(s)+\astrm(s)\cdot\der{\bstrm(s)}}
        \end{align*}

    \end{proof}

    \begin{definition}\label{def:termvars}
        We define by
        \begin{equation*}
            % TODO: what if x'[] in term ?
            \constants[\astrm] \defeq \Set{c\in\constants \with \mexists{x\in\allvars}\holds\x[c]\in\astrm(s)}
        \end{equation*}
        the set of constant parameter symbols occurring in the s-term $\astrm(s)$.

        Note that this set does not contain $s$, since it is, as a special purpose symbol, not in $\constants$.
    \end{definition}

    \begin{definition}[Sampled trajectory]\label{def:sampled-trajectory}
        Since a s-term $\astrm(s)$ only comprises a finite number of atomic terms, its valuation can also be seen as a mapping
        \begin{equation*}
            \ivaluation{\interpretation[const=\interpret]}{\astrm(s)} \from \R^{\abs{\mathcal{K}}} \to \R
        \end{equation*}
        % TODO: what about x'
        from the concrete values for each element of the finite set $\mathcal{K}\defeq \delayvars[\astrm] \cup \delaydiffvars[\astrm] \cup \Set{\x[s], \Dx[s]}$ into the reals, if we assign a fixed $r\in\closeddelayinterval$ to $s$.

        % , instead of using the functional state space as domain.

        This gives rise to the definition of the \emph{sampled trajectory} $\sampledtraj[\past]{\astrm}\from\compactum{0}{\duration}\to\R^{\abs{\mathcal{K}}}$ for a fixed $\past\in\closeddelayinterval$ and s-term $\astrm(s)$, which looks in the case $\allvars=\Set{x}$ like
        % FIXME: differnt vars possible, not just x
        \begin{equation*}
            \sampledtraj[\past]{\astrm}(t) \defeq \colvec{
                \trajectory(t)(x)(c_1)\\
                \vdots\\
                \trajectory(t)(x)(c_n)
            % \\ \vdots\\ \trajectory(t)(x_m)(c_1)\\ \vdots\\ \trajectory(t)(x_m)(c_n)
            }
        \end{equation*}
    \end{definition}
    % TODO: alternatively, could maybe have \trajectory Fréchet-diffable

    The following lemma is the DDE counterpart to the differential lemma for ODEs~\cite{Platzer15Uniform} and shows the consistency of the semantics for differentials with the semantics of the evolution of a delay differential equation.
    This means that along a DDE, the values of differential symbols coincide with the time derivative of the value of the corresponding variable.
    % Derivative means right-hand in points of partition.

    \begin{lemma}[Differential Lemma]\label{lm:differential-lemma}
        % FIXME: check if everywhere correctly used: \states=(\statespace)^n
        % FIXME: check if alle Annahmen, e.g. FV
        The value of a s-term $\bstrm(s)$ along a trajectory $\trajectory\from\compactum{0}{\duration}\to\states$ satisfying a DDE for any duration $\duration>0$, i.e.
        % FIXME:doFormatList does not work with iconcat $\imodels{\iconcat[state=\trajectory]{\IddL}}{\D{x}=\asfml\land\ivr}$
        $\interpret,\trajectory\models(\D{x}=\astrm\land\ivr)$,
        % FIXME: do I need case s=0?
        is piecewise continuously differentiable and for all $\zeta\in\compactum{0}{\duration}$ and $\past\in\closeddelayinterval$ it holds:
        \begin{equation*}
            \ivaluation{\iconcat[state=\trajectory(\zeta)]{\IddL}}{\D{(\bstrm(s))}} = \DD{\ivaluation{\iconcat[state=\trajectory(t)]{\IddL}}{\bstrm(s)}}{t}(\zeta)
        \end{equation*}
        % FIXME: replace with def here, use notation d+/dt f(zeta) for right derivative
        As in Definition~\ref{def:pw-cont-diff}, the derivative at a ``bend point'' is to be understood as right derivative.
    \end{lemma}
    \begin{proof}
        \label{prf:differential-lemma}
        % TODO: what if x'[] in term ?
        % TODO: in init cond: x and x' need to match, ie d/ds x[s] = x'[s], same partition, specification of x' in init cond only needed when referenced to it later
        % FIXME: oBdA: t_0=0

        Without loss of generality, we restrict in this proof to a single variable $x$. If $\bstrm(s)$ depends on more variables, consider the union of their partitions in the initial condition.
        Let $\partition{-T=t_0}{t_p=0}$ be the partition of the initial condition $\trajectory(0)(x)\in\statespace$.

        We choose an arbitrary but fixed valuation $\past\in\closeddelayinterval$ for $s$, such that the symbol $s$ can be treated as a constant parameter, in the same way as any $c\in\nonposQ$.
        Depending on the s-term $\bstrm(s)$ and the fixed $\past$, we define a partition $\mathcal{Z}_\bstrm^s=\partition{\hat{t}_0}{\hat{t}_q}$ of $\closedopen{0}{\infty}$ (which can be limited to $\compactum{0}{R}$) by
        \begin{equation*}
            \mathcal{Z}_\bstrm^\past \defeq \bigcup_{i=0}^m\bigcup_{\substack{c\in \mathcal{K}\\ t_i\geq c}}\set{t_i-c}\cup \bigcup_{i=0}^m\bigcup_{j=1}^k\bigcup_{\substack{c\in \mathcal{K}\\ t_i+\tau_j\geq c}}\set{t_i+\tau_j-c}
        \end{equation*}
        where $\mathcal{K}\defeq\constants[\bstrm]\cup\set{0,\past}$ is the set of the constants (the interpretations of their symbols) appearing in the term $\bstrm$ and $\tau_j\in\constants[\astrm]$ the delays in the right hand side of the DDE.
        The set $\mathcal{Z}_\bstrm^\past$ is finite and non-empty, since it contains at least the value $0$.

        We show first that $\trajectory(t)(x)(c)$ is piecewise continuously differentiable in $t$ for each $c\in\mathcal{K}$ with partition $\mathcal{Z}_\bstrm^\past$:

        Let $c\in\mathcal{K}$ and $\zeta\in(\hat{t}_l,\hat{t}_{l+1})$.
        Assume that $\zeta+c=t_i$ for some $i$. This implies $\zeta=t_i-c=\hat{t}_k$ for some $k$ by the definition of the partition. This is not possible by the choice of $\zeta$ lying between two consecutive $\hat{t}_l$.
        We apply the same argumentation to the assumption $\zeta+c=t_i+\tau_j$.
        These contradictions show that for $\zeta\in(\hat{t}_l,\hat{t}_{l+1})$, it holds that $\zeta+c\neq t_i$ and $\zeta+c\neq t_i+\tau_j$ for all $c\in\mathcal{K}$ and for all $i\in\Set{\range{0}{m}}$ and $j\in\set{\range{1}{k}}$.
        We now distinguish two cases:

        If $\zeta+c<0$, it holds by the definition of the DDE semantics (Definition~\ref{def:semantic-dHP}(\ref{itm:sem-HP-DDE})) that $\trajectory(\zeta)(x)(c)=\trajectory(0)(x)(\zeta+c)$, which is continuously differentiable as initial condition, if $\zeta+c\neq t_i$. Hence it follows
        \begin{equation*}
            \DD{\trajectory(t)(x)(c)}{t}(\zeta)=\DD{\trajectory(0)(x)(\past)}{\past}(\zeta+c)=\trajectory(0)(\D{x})(\zeta+c)=\trajectory(\zeta)(\D{x})(c)
        \end{equation*}
        For the right limit it holds
        \begin{align*}
            \lim_{\zeta\downto\hat{t}_l} \DD{\trajectory(t)(x)(c)}{t}(\zeta)
                & = \lim_{\zeta\downto \hat{t}_l} \DD{\trajectory(0)(x)(\past)}{\past}(\zeta+c)\\
                &
                %=\lim_{s\downto t_i}\trajectory(0)(\D{x})(s)
                = \trajectory(0)(\D{x})(\hat{t}_l+c)
        \end{align*}
        since $\zeta+c\in\open{t_i}{t_{i+1}}$.
        And analogously for the existence of the left limit for $\zeta\upto\hat{t}_{l+1}$

        If $\zeta+c\geq 0$, then $\trajectory(\zeta)(x)(c)=\trajectory(\zeta+c)(x)(0)$ is differentiable in $\zeta$ with
        \begin{equation*}
            \DD{\trajectory(t)(x)(c)}{t}(\zeta) = \trajectory(\zeta)(\D{x})(c)
        \end{equation*}
        by the semantics of the DDEs, if $\zeta+c\neq t_i+\tau_j$.
        % FIXME: jumppoints and pw conitnuity/diffable
        % By Theorem~\ref{thm:solution-existence}: continuous and pw diffable with partition $Z$.

        % By definition, $\hat{t}_j=t_i-\hat{c}$ for some $i\in\set{\range{0}{m}}$ and $\hat{c}\in\mathcal{K}$.
        % If $c\geq\hat{c}$ then $\zeta>\hat{t}_j$ implies $\zeta+c > c+t_i-\hat{c}\geq t_i$.
        % If $c<\hat{c}$, then $\zeta < \hat{t}_{j+1} \leq t_i-c$ (needs explanation: tjp1 is smallest next point, construct one, must be greater or equal) and hence $\zeta+c<t_i$.
        % So whenever $\zeta\in(\hat{t}_j,\hat{t}_{j+1})$ is $\zeta+c\neq t_i$ for all $i=\range{0}{m}$ and $c\in\mathcal{K}$

        %On each $\zeta\in(\hat{t}_k,\hat{t}_{k+1})$ is each $\ivaluation{\iconcat[state={\trajectory(\zeta)},assign=s]{\IddL}}{\x[c]}$ diffable in $\zeta$

        % TODO: f in terms smooth, hence each term on this open interval diffable
        Let $\sampledtraj[\past]{\bstrm}$ be the $\bstrm$-sampled trajectory for the considered delay differential equation and the fixed $\past$.
        It follows with the above results
        % By the transition semantics of DDEs (Definition~\ref{def:semantic-HP}\,(\ref{itm:sem-HP-DDE})), it holds for $\zeta+c\geq 0$ (along sol of DDE)
        % $\trajectory(\zeta)(\D{x})(c) = \DD{\trajectory(t)(x)(c)}{t}(\zeta)$, and for $\zeta+c\leq 0$ (init cond, match demanded)

        \begin{align*}
            \DD{\ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\zeta)},assign={}]{\IddL}}{\bstrm}}{t}
            &= \D{\left(\ivaluation{\iconcat[state={},assign={}]{\IddL}}{\bstrm}\compose\sampledtraj[\past]{\bstrm}(\zeta)\right)}
            = \gradient{\ivaluation{\iconcat[state={},assign={}]{\IddL}}{\bstrm}}(\sampledtraj[\past]{\bstrm}(\zeta))\cdot\DD{\sampledtraj[\past]{\bstrm}}{t}(\zeta)\\
            &= \sum_{\x[c]\in\delayvars[\bstrm]}\DD{\trajectory(t)(x)(c)}{t}(\zeta) \Dp[{(\x[c])}]{\ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\zeta)}]{\IddL}}{\bstrm}}\\
            % &= \sum_{\x[c]\in\delayvarswiths}\trajectory(\zeta)(\Dx[c])(s) \Dp[{(\x[c])}]{\ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\zeta)},assign=s]{\IddL}}{\bstrm}}{(s)}\\
            &= \sum_{\x[c]\in\delayvars}\trajectory(\zeta)(\D{x})(c) \Dp[{(\x[c])}]{\ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\zeta)}]{\IddL}}{\bstrm}}\\
            %&= \sum_{\x[c]\in\delayvarswiths}\asstate(\D{x})(c) \Dp[{(\x[c])}]{\ivaluation{\IddL}{\bstrm}}{(s)}\\
            &= \ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\zeta)},assign={}]{\IddL}}{\D{(\bstrm})}
        \end{align*}
        where each sum only consists of finitely many summands.
        Moreover, it holds for the right limits
        \begin{equation*}
            \lim_{\zeta\downto\hat{t}_l} \DD{\ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\zeta)}]{\IddL}}{\bstrm}}{t} = \ivaluation{\iconcat[state={\sampledtraj[\past]{\bstrm}(\hat{t}_l)},assign={}]{\IddL}}{\D{(\bstrm})}
        \end{equation*}
        and the left limits for $\zeta\upto\hat{t}_{l+1}$ exist.
    \end{proof}

    \begin{figure}[t]
        \centering
        \input{figures/differential-lemma.tikz}
        \caption{Plot for Example~\ref{ex:differential-lemma}, initial condition and solution of DDE (dashed), derivatives (dotted), value of term (solid) and the derivative of the term (dash-dotted).}
        \label{fig:differential-lemma}
    \end{figure}

    \begin{example}\label{ex:differential-lemma}
        As an example for the construction of the partition in Proof~\ref{prf:differential-lemma}, consider the s-term $\bstrm(s)\equiv x+\x[-3.5]+\x[s]$ together with the DDE $\D{x}=\x[-4]$.
        Let
        \begin{equation*}
            \mathcal{Z} = \Set{-4,-3.25,-2,-1.2,0}
        \end{equation*}
        be the partition of some initial condition.
        Choosing $\past=-1.8$ for $s$, we obtain
        \begin{equation*}
            \mathcal{Z}_\bstrm^\past = \set{0,0.25,0.6,0.75,1.5,1.8,2,2.3,2.55,2.8,3.5,3.8,4}
        \end{equation*}
        when we restrict the evolution to $\compactum{0}{4}$.
        Figure~\ref{fig:differential-lemma} depicts an example for the piecewise continuous differentiability of the term's evolution, given some initial condition.
        % \begin{equation*}
        %     \D{\left(\hs{x+\x[c]+\x[s]\geq 0}\right)} \equiv \hs{\D{x}+\Dx[c]+\Dx[s]\geq 0}
        % \end{equation*}

        % then $g_s\in\Cnpw[1]{\compactum{0}{r}}{\R}$ along traj de dde
        % \begin{equation*}
        %     g_s(t)=\ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\bstrm} = \ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\x[0]} + \ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\x[c]} + \ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\x[s]}
        % \end{equation*}
        % each summand diffable in $(\hat{t}_j,\hat{t}_{j+1})$ and
        % \begin{equation*}
        %     \D{g}_s(t)= \ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\Dx[0]} + \ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\Dx[c]} + \ivaluation{\iconcat[state=\trajectory(t),assign=s]{\IddL}}{\Dx[s]}
        % \end{equation*}
        % \begin{equation*}
        %     \lim_{\zeta\downto\hat{t}_j} \D{g}_s(\zeta)=
        % \end{equation*}
    \end{example}

    % FIXME: replace duration r
    \begin{lemma}[Differential assignment]\label{lm:diff-assignment}
        Let $\trajectory\from\compactum{0}{\duration}\to\states$ be a trajectory satisfying a DDE for any duration $\duration\geq 0$, i.e.
        $\interpret,\trajectory\models(\D{x}=\astrm\land\ivr)$.
        Then it holds for $\past\in\closeddelayinterval$:
        % FIXME: change notation without zeta
        \begin{equation*}
            \interpret,\trajectory,\past\models\asfml(s) \mbisubjunct \trajectory(\zeta)\in\imodel{\IddL}{\dbox{\Dupdate{\Dumod{\D{x}}{\astrm}}}{\asfml(s)}}
        \end{equation*}
    \end{lemma}
    \begin{proof}
        Let $\zeta\in\compactum{0}{\duration}$. It is $\trajectory(\zeta)\in\imodel{\iconcat[assign={}]{\IddL}}{\Dx[0]=\astrm}$ and $\trajectory(\zeta)\in\imodel{\iconcat[assign={}]{\IddL}}{\ivr}$, which means $\trajectory(\zeta)(\D{x})(0)=\ivaluation{\iconcat[state=\trajectory(\zeta),assign={}]{\IddL}}{\astrm}$.
        % , since $\astrm$ is independent of $s$.
        By Definition~\ref{def:semantic-dHP}(\ref{itm:sem-dHP-assgn}) of the assignment's semantics, this implies $(\trajectory(\zeta),\bsstate)\in\ireachability{\IddL}{\Dupdate{\Dumod{\D{x}}{\astrm}}}$ if and only if $\bsstate=\trajectory(\zeta)$.
        Finally, this implies the equivalence
        \begin{align*}
            \trajectory(\zeta)\in\imodel{\IddL}{\asfml(s)} &\lbisubjunct
            \mforall{\bsstate\in\states}\holds\left((\trajectory(\zeta),\bsstate)\in\ireachability{\IddL}{\Dupdate{\Dumod{\D{x}}{\astrm}}} \limply \bsstate\in\imodel{\IddL}{\asfml(s)}\right)\\
            &\lbisubjunct \trajectory(\zeta)\in\imodel{\IddL}{\dbox{\Dupdate{\Dumod{\D{x}}{\astrm}}}{\asfml(s)}}
        \end{align*}
    \end{proof}

\section{Static Semantics}
    \label{sec:static-semantics}

    The static semantics of \ddL formulas and \dHPs defines some properties, which can be derived solely from their syntactic structure and without execution of their programs.
    We adapt the notion of \emph{free} and \emph{bound} occurrences of variables in formulas and introduce the so called \emph{history horizon}.

    \subsection{History Horizon}
        \label{sec:history-horizon}

        Delay hybrid programs and \ddL formulas can reference past values of variables. These values need to be specified by the state.
        For that reason, the lower interval bound $T\in\nonposR$ of the state space domain needs to be chosen accordingly.

        This bound is called \emph{history horizon} and depends on all occurrences of $\x[c]$ and $\Dx[c]$ in the formula and the hybrid programs it contains.
        The concrete value of $T$ needs to be known in order to determine the validity of a formula, since it appears explicitly in the quantification $\hs{}$ for the special variable $s$.

        \begin{definition}[History Horizon]
            The \emph{history horizon} is a function
            % \begin{equation*}
            %     \HH\from \ddLformulas \to \nonposR
            % \end{equation*}
            which
            assigns to each \ddL formula the earliest point in time it references to.
            It is defined inductively for s-formulas by:
            % TODO: compactify by combining equalities to single line
            % TODO: mention c in Q in entsprechenden lines
            \begin{align*}
                \HH{\astrm(s)=\bstrm(s)} = \HH{\astrm(s)\geq\bstrm(s)} &= \max\set{\HH{\astrm(s)},\HH{\bstrm(s)}}\\
                \HH{p(\range{\istrm{1}(s)}{\istrm{k}(s)})} &= \max\set{\range{\HH{\istrm{1}(s)}}{\HH{\istrm{k}(s)}}}\\
                % FIXME: here max(T,HH(phi)) needed?
                \HH[\big]{\hs{\asfml(s)}} &= \HH{\asfml(s)}\\
                \HH{\lnot\asfml(s)} &= \HH{\asfml(s)}\\
                \HH{\asfml(s)\land\bsfml(s)} &= \max\set{\HH{\asfml(s)},\HH{\bsfml(s)}}\\
                \HH{\lforall{x}{\asfml(s)}} = \HH{\lexists{x}{\asfml(s)}} &= \HH{\asfml(s)}\\
                \HH{\dbox{\asprg}{\asfml(s)}} = \HH{\ddiamond{\asprg}{\asfml(s)}} &= \max\set{\HH{\asprg},\HH{\asfml(s)}}\\
            \end{align*}
            depending on the \emph{history horizon} for s-terms
            \begin{align*}
                \HH{\x[s]} &= 0\\
                \HH{\Dx[s]} &= 0\\
                \HH{\x[c]} &= \abs{c}\\
                \HH{\Dx[c]} &= \abs{c}\\
                \HH{a} &= 0\\
                \HH{f(\range{\istrm{1}(s)}{\istrm{k}(s)})} &= \max\set{\range{\HH{\istrm{1}(s)}}{\HH{\istrm{k}(s)}}}\\
                \HH{\astrm(s)+\bstrm(s)} &= \max\set{\HH{\astrm(s)},\HH{\bstrm(s)}}\\
                \HH{\astrm(s)\cdot\bstrm(s)} &= \max\set{\HH{\astrm(s)},\HH{\bstrm(s)}}
            \end{align*}
            and for \dHPs
            \begin{align*}
                \HH{\hupdate{\humod{x}{\astrm}}} &= \HH{\astrm}\\
                \HH{\Dupdate{\Dumod{\D{x}}{\astrm}}} &= \HH{\astrm}\\
                \HH{\htest{\asfml}} &= \HH{\asfml}\\
                \HH{\hchoice{\asprg}{\bsprg}} &= \max\set{\HH{\asprg},\HH{\bsprg}}\\
                \HH{\asprg;\bsprg} &= \max\set{\HH{\asprg},\HH{\bsprg}}\\
                \HH{\hrepeat{\asprg}} &= \HH{\asprg}\\
                \HH{\hevolvein{\D{x}=\astrm}{\ivr}} &= \HH{\astrm}
            \end{align*}
        \end{definition}
        %We need to use $\min$, since $\HH$ is a non-positive number. It is the biggest in absolute value.
        \begin{example}
            Consider the following \ddL formula:
            \begin{multline*}
                \hsc{(\x[s]=2)}\limply\\
                \dbox{\hupdate{\humod{x}{\x[-3]\cdot\x[-3]}};\hevolvein{\D{x}=\x[-\tau]+2x}{(x\geq 0)}}{\big(\hsc{0\leq\x[s] \land \x[s]\leq\x[-5]}\big)}
            \end{multline*}
            The history horizon needs to be set to
            \begin{align*}
                T&=\max\set{\max\set{3,\tau},\max\set{0,5}}\\
                &=\max\set{\tau,5}.
            \end{align*}
        \end{example}

    \subsection{Variable Binding}
        \label{sec:variable-binding}

        % TODO: explain differences free/bound/must bound variables
        Similar to  \dL~\cite{Platzer15Uniform}, we define \emph{free}, \emph{bound} and \emph{must bound} variables.
        These notions are needed for the sound definition of axioms, whenever they incorporate a substitution.
        A variable $x$ is bound by quantifiers of the form $\lforall{x}$ or $\exists{x}$ or through discrete assignments or differential evolutions inside a modality, such as $\dbox{\hupdate{\humod{x}{4}}}{}$ or $\ddiamond{\hevolve{\D{x}=\x[-1]}}$.
        The only way to bind the special variable $s$ is by appearing inside the scope of $\hs{}$.

        More precisely, these notions can be defined by simultaneous induction over the syntax:
        \begin{definition}[Free variable]
            For s-terms, we define the set $\freevars{\astrm(s)}\subseteq\allvars\cup\diffvars\cup\set{s}$ of \emph{free variables} as the variables that occur in this term:
            % FIXME: bigger outer parentheses for FV/BV
            \begin{align*}
                \freevars{\x[s]} &= \set{x,s}\\
                \freevars{\Dx[s]} &= \set{\D{x},s}\\
                \freevars{\x[c]} &= \set{x}, \quad c\in\Q\\
                \freevars{\Dx[c]} &= \set{\D{x}}, \quad c\in\Q\\
                \freevars{a} &= \emptyset\\
                \freevars[\big]{f(\range{\istrm{1}(s)}{\istrm{k}(s)})} &= \freevars{\istrm{1}(s)} \cup\cdots\cup \freevars{\istrm{k}(s)}\\
                \freevars[\big]{\astrm(s)+\bstrm(s)} = \freevars[\big]{\astrm(s)\cdot\bstrm(s)} &= \freevars{\astrm(s)}\cup\freevars{\bstrm(s)}\\
                \freevars[\big]{\der{\astrm(s)}} &= \freevars{\astrm(s)}\cup\D{\freevars{\astrm(s)}}
            \end{align*}
            The set $\freevars{\asfml(s)}\subseteq\allvars\cup\diffvars\cup\set{s}$ for a s-formula is defined as all its variables which appear outside the scope of quantifiers or modalities which bind it:
            \begin{align*}
                \freevars[\big]{\astrm(s)=\bstrm(s)} = \freevars[\big]{\astrm(s)\geq\bstrm(s)} &= \freevars{\astrm(s)}\cup\freevars{\bstrm(s)}\\
                \freevars[\big]{p(\range{\istrm{1}(s)}{\istrm{k}(s)})} &= \freevars{\istrm{1}(s)} \cup\cdots\cup \freevars{\istrm{k}(s)}\\
                \freevars[\big]{\hs{\asfml(s)}} &= \freevars{\asfml(s)}\setminus\set{s}\\
                \freevars{\lnot\asfml(s)} &= \freevars{\asfml(s)}\\
                \freevars{\asfml(s)\land\bsfml(s)} &= \freevars{\asfml(s)}\cup\freevars{\bsfml(s)}\\
                \freevars{\lforall{x}{\asfml(s)}} = \freevars{\lexists{x}{\asfml(s)}} &= \freevars{\asfml(s)}\setminus\set{x}\\
                \freevars{\dbox{\asprg}{\asfml(s)}} = \freevars{\ddiamond{\asprg}{\asfml(s)}} &= \freevars{\asprg}\cup\left(\freevars{\asfml}\setminus\mustboundvars{\asprg}\right)\\
            \end{align*}
            For a \dHP $\asprg$, its free variables $\freevars{\asprg}\subseteq\allvars\cup\diffvars$ are those which are potentially read:
            \begin{align*}
                \freevars{\hupdate{\humod{x}{\astrm}}} = \freevars{\Dupdate{\Dumod{\D{x}}{\astrm}}} &= \freevars{\astrm} \\
                \freevars{\htest{\asfml}} &= \freevars{\asfml}\\
                \freevars{\hchoice{\asprg}{\bsprg}} &= \freevars{\asprg}\cup\freevars{\bsprg}\\
                \freevars{\asprg;\bsprg} &= \freevars{\asprg}\cup\left(\freevars{\bsprg}\setminus\mustboundvars{\asprg}\right)\\
                \freevars{\hrepeat{\asprg}} &= \freevars{\asprg}\\
                \freevars{\hevolvein{\D{x}=\astrm}{\ivr}} &= \set{x}\cup\freevars{\astrm}\cup\freevars{\ivr}
            \end{align*}
        \end{definition}

        Only bound variables can change their value during the execution of a delay hybrid program.
        For formulas, bound variables are the variables which don't need an assignment in order to determine the truth value of the formula.
        \newpage

        \begin{definition}[Bound variable]
            The set $\boundvars{\asfml(s)}\subseteq\allvars\cup\diffvars\cup\set{s}$ of a s-formula is defined as:
            \begin{align*}
                \boundvars[\big]{\astrm(s)=\bstrm(s)} = \boundvars[\big]{\astrm(s)\geq\bstrm(s)} &= \emptyset\\
                \boundvars[\big]{p(\range{\istrm{1}(s)}{\istrm{k}(s)})} &= \emptyset\\
                \boundvars[\big]{\hs{\asfml(s)}} &= \set{s}\cup\boundvars{\asfml(s)}\\
                \boundvars{\lnot\asfml(s)} &= \boundvars{\asfml(s)}\\
                \boundvars{\asfml(s)\land\bsfml(s)} &= \boundvars{\asfml(s)}\cup\boundvars{\bsfml(s)}\\
                \boundvars{\lforall{x}{\asfml(s)}} = \boundvars{\lexists{x}{\asfml(s)}} &= \set{x}\cup\boundvars{\asfml(s)}\\
                \boundvars{\dbox{\asprg}{\asfml(s)}} = \boundvars{\ddiamond{\asprg}{\asfml(s)}} &= \boundvars{\asprg}\cup\boundvars{\asfml(s)}\\
            \end{align*}
            The set of \emph{bound variables} $\boundvars{\asprg}\subseteq\allvars\cup\diffvars$ of a \dHP $\asprg$ are the variables which are potentially written:
            \begin{align*}
                \boundvars{\hupdate{\humod{x}{\astrm}}} &= \set{x} \\
                \boundvars{\Dupdate{\Dumod{\D{x}}{\astrm}}} &= \set{\D{x}} \\
                \boundvars{\htest{\asfml}} &= \emptyset\\
                \boundvars{\hchoice{\asprg}{\bsprg}}
                = \boundvars{\asprg;\bsprg} &= \boundvars{\asprg}\cup\boundvars{\bsprg}\\
                \boundvars{\hrepeat{\asprg}} &= \boundvars{\asprg}\\
                \boundvars{\hevolvein{\D{x}=\astrm}{\ivr}} &= \set{x,\D{x}}
            \end{align*}
        \end{definition}

        \begin{definition}[Must-bound variable]
            The set of \emph{must-bound variables} $\mustboundvars{\asprg}\subseteq\allvars\cup\diffvars$ of a \dHP $\asprg$, are the variables which are written at all execution paths:
            \begin{align*}
                \mustboundvars{\hupdate{\humod{x}{\astrm}}} &= \boundvars{\hupdate{\humod{x}{\astrm}}} = \set{x} \\
                \mustboundvars{\Dupdate{\Dumod{\D{x}}{\astrm}}} &= \boundvars{\Dupdate{\Dumod{\D{x}}{\astrm}}} = \set{\D{x}} \\
                \mustboundvars{\htest{\asfml}} &= \boundvars{\htest{\asfml}} = \emptyset\\
                \mustboundvars{\hchoice{\asprg}{\bsprg}} &= \mustboundvars{\asprg}\cap\mustboundvars{\bsprg}\\
                \mustboundvars{\asprg;\bsprg} &= \mustboundvars{\asprg}\cup\mustboundvars{\bsprg}\\
                \mustboundvars{\hrepeat{\asprg}} &= \emptyset\\
                \mustboundvars{\hevolvein{\D{x}=\astrm}{\ivr}} &= \boundvars{\hevolvein{\D{x}=\astrm}{\ivr}} = \set{x,\D{x}}
            \end{align*}
            Obviously, it holds $\mustboundvars{\asprg}\subseteq\boundvars{\asprg}$.
        \end{definition}

%

%     \subsection{Well-defined Formulae}
%         \label{sec:well-definedness}

%         $s$ must not be free
%         and

%         \begin{definition}[Well-defined formula]
%             obeys syntactic definition
%             premisse defines element od statespace for all occuring variables and diffs
%         \end{definition}

%

%         % TODO: feasible history horizon for a HP
%         \begin{lemma}
%             choosing the statespace according to history horizon of HP determines
%         \end{lemma}

%         \begin{example}

%         \end{example}
